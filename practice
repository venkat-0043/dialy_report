
								
								slicing works different with mutable and immutable
								--------------------------------------------------

example: THIS IS VERY IMPORTANT
--------
-->The [:] syntax works for lists. However, there is an important difference between how this operation works with a list and how it works with a string.

If s is a string, s[:] returns a reference to the same object:

>>> s = 'foobar'
>>> s[:]
'foobar'
>>> s[:] is s
True

-->the main thing is the slicing works different way when comes to the mutable and the immutable data types. but when comes to the list it is different. see below : 
exmaple :
--------
a = [1,2,3]
print(a is a[:])

output:
-------
False

-->here the a and a[:], they both pointing to the different address. but when come to the string it is different. not only string, if you take any other immutable object, it works different way. let's take a look at the tuple : 
example:
--------
a = (1,2,3)
print(a is a[:])

output:
-------
True

-->here the 'a' and 'a[:]', they pointing the same address.

---------------------------------------------------------------------------------------------------------------

-->find a given number is armstrong number or not 

solution :
----------
def armstrong(number):
    total = 0
    for i in number:
        total = total + int(i) ** 3

    if int(number) == total:
        print(f'the number {number} is the armstrong number')
    else:
        print(f'the number {number} is not armstrong')

number = input('enter the number : ')

armstrong(number)


--------------------------------------------------------------------------------------------------------------

Task
Given an integer, , perform the following conditional actions:

If  is odd, print Weird
If  is even and in the inclusive range of 2 to 5, print Not Weird
If  is even and in the inclusive range of 6 to 20, print Weird
If  is even and greater than 20, print Not Weird

solution :
----------
def func(n):
    if n % 2 != 0:
        return 'wierd'
    elif n % 2 == 0:
        if n in range(2, 6):
            return 'not weird'
        elif n in range(6, 21):
            return 'weird'
        elif n > 20:
            return 'not weird'

print(func(int(input('enter the number : '))))

output:
-------
enter the number : 5
wierd


--------------------------------------------------------------------------------------------------------------

Minion game:
------------

Game Rules

Both players are given the same string, .
Both players have to make substrings using the letters of the string .
Stuart has to make words starting with consonants.
Kevin has to make words starting with vowels.
The game ends when both players have made all possible substrings.

Scoring
A player gets +1 point for each occurrence of the substring in the string .

For Example:
String  = BANANA
Kevin's vowel beginning word = ANA
Here, ANA occurs twice in BANANA. Hence, Kevin will get 2 Points.

solution:
---------
def minion(string):
    vowels = ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
    stuart_score = 0
    kevin_score = 0
    kevin_words = []
    stuart_words = []

    for i in range(len(string)):
        if string[i] not in vowels:
        	#this count the combinations based on the count like for 'hell' it takes h, he, hel, hell
            stuart_score += len(string[i : ])
            
        elif string[i] in vowels:
            kevin_score += len(string[i : ])
            
    print('stuart score is :',  stuart_score)
    print('kevin score is : ', kevin_score)

    if stuart_score > kevin_score:
        print('stuart wins')

    elif stuart_score < kevin_score:
        print('kevin wins')
        
    else:
        print('both wins')


minion(input('enter the string : '))

-->the above code can give you the number of combinations, but it don't print all the word combinations. below code prints all the details : 

solution : 
----------
def minion(string):
    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']
    stuart_score = 0
    kevin_score = 0
    kevin_words = []
    stuart_words = []

    for i in range(len(string)):
        if string[i] not in vowels:
            temp = string[i : ]
            #this count the combinations based on the count like for 'hell' it takes h, he, hel, hell
            stuart_score += len(string[i : ])
            for i in range(len(temp)):
                stuart_words.append(temp[0 : i + 1])
            
            
        elif string[i] in vowels:
            temp = string[i : ]
            #this count the combinations based on the count like for 'hell' it takes h, he, hel, hell
            kevin_score += len(string[i : ])
            for i in range(len(temp)):
                kevin_words.append(temp[0 : i + 1])
            
    print('stuart score is :',  stuart_score)
    print('\nstuart combination words :',  stuart_words)
    print('\nkevin score is : ', kevin_score)
    print('\nkevin combination words :', kevin_words)

    if stuart_score > kevin_score:
        print('\nstuart wins')

    elif stuart_score < kevin_score:
        print('\nkevin wins')
        
    else:
        print('\nboth wins')


minion(input('enter the string : '))

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



												29-12-2021
												----------


functions:
----------
-->the type of the function variable, it is always belogns to the class 'function', see below :

example:
--------
def func():
    pass

print(type(func))

output:
-------
<class 'function'>


-->if you check the return type of the function, then it will return "NoneType" if it is not returning anything, if it is return anything, then it return the data type of the returning values. see below : 

example:
--------
def func():
    pass

print(type(func()))

output:
-------
<class 'NoneType'>


-->for example if the function is returning the string, then the return type of the function is string. see below : 

example:
--------
def func():
    return 'hello world'

print(type(func()))

output:
-------
<class 'str'>


functions vs methods:
----------------------
-->if we write the function inside the class, then the type of that function is not 'class function'. see below :

example:
--------
class Hello:

    def func(self):
        pass

obj = Hello()
print(type(obj.func))

output:
--------
<class 'method'>

-->here, when we write the function inside the class, the type of that function variable is changed to 'class method'. if we don't write the function inside the class, then that' function variable's return type is 'class function'. this one of the way to identify the difference between the functions and methods. 


inner functions:
----------------
-->these are just function within another function, we can call them as the nested functions.

example:
--------
def outer():
    print('this is the outer function')
    def inner():
        print('this is the inner function')
    return inner()

outer()

output:
-------
this is the outer function
this is the inner function


encapsulation with inner functions:
-----------------------------------
-->A common use case of inner functions arises when you need to protect, or hide, a given function from everything happening outside of it so that the function is totally hidden from the global scope. This kind of behavior is commonly known as encapsulation.

example:
--------
def add(number):
    def inner():
        return number + 1
    return inner()

inner()

output:
-------
Traceback (most recent call last):
  File "C:\Users\this\Desktop\sample1.py", line 6, in <module>
    inner()
NameError: name 'inner' is not defined

-->here we can't access the inner function directly, because the outer function is hiding the inner function from accessing directly.


-->the inner function has access to the outer functions state.

example:
--------
def square(number):
    def inner(power):
        return number ** power
    return inner(2)

print(square(10))
    
output:
-------
100

-->here the inner function has the access to the outer function data 'number'. 

example : writing multiple nested functions
---------
def square(number):
    def outer(power):
        def inner():
            return number ** power
        return inner()
    return outer(2)

print(square(10))
    
output:
-------
100

-->here the 'inner' function has the access to the parameters of the outer functions outer and square.



recursion functions:
--------------------
-->a function which calls itself again and again. 

example: calculate the sum of first 10 numbers
--------
def func(number):
    if number == 1:
        return 1
    else:
        return number + func(number - 1)

print(func(20))

output:
-------
55


-->there is another way we can write the above program

example:
--------
def func(number):
    return number + func(number - 1) if number > 0 else 0 

print(func(5))

output:
--------
15


example: calculate the factorial of a number using recursion 
--------
def func(number):
    if number == 1:
        return 1
    else:
        return number * func(number - 1)

print(func(6))

output :
--------
720


functions are the fist class object:
------------------------------------
-->the functions in python are called as the first class objects, there are 4 main reasons : 
1)we can return a function from another function
2)we can pass the function as the argument to anothe function
2)we can store the return value of the function in a variable
4)we can create one function within another function

pass function as the argument:
------------------------------
example:
--------
def add():
    return 10 + 20

def result(add):
    value = add()
    return value

print(result(add))

output:
-------
30

-->here I passed the function 'add' as the argument to the function 'result'. we can also pass the anonymous functions 'lambda' as the argument to another function. see below :

example:
--------
def result(add):
    value = add()
    return value

print(result(lambda : 10 + 20))

output:
--------
30

-->we can also write the above program by simplye storing the lambda function in a variable and pass that variable. see below : 

example:
--------
def result(add):
    value = add()
    return value

value = lambda : 10 + 20
print(result(value))

output:
-------
30


-->let's prints numbers from 1 to 10, by passing the function as the argument in the list comprehension
example:
--------
def func():
    return 10

print([i for i in range(func())])

output:
-------
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]




Task:
-----
-->in the below list, find the names with maximum marks and sorted the names

solution:
---------
data = [['b', 10], ['c', 20], ['a', 20]]

names = []
marks = []

for i, j in data:
    names.append(i)
    marks.append(j)

max_marks = max(marks)

list1 = []

for i, j in data:
    if j == max_marks:
        list1.append(i)

print(sorted(list1))

output:
-------
['a', 'c']


Task:
-----
-->sort dictionary based on values:

solution:
---------
data = [['b', 10], ['a', 20], ['c', 20]]

names = []
marks = []
dict1 = {}

for i, j in data:
    dict1[i] = j

for i, j in dict1.items():
    value = max(dict1.values())
    if j == value:
        print(i)

output:
-------
a
c


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

												Decorators(3-1-2022)
												--------------------

-->the decorators pattern is an object oriented design pattern that allows behaviour to be added to an existing object dynamically. when you decorate an object then you extend it's functionality in a way that is independet of other instances of the same class.

-->python decorators add functionality to functions and methods at the definitions time, they are not used to add the functinality at run time.

-->we have 2 types of decorators in python. decorators can be applied to both functions and classes.
1)function decorator
2)class decorator


function decorator:
-------------------
-->to implement the function decorator, we need 2 functions. one function is to take the decorator function as the argument and an inner function to call the decorator function. first let's see how the inner functions works. 

example:
--------
def outer():
    print('this is the outer function')
    def inner():
        print('this is the inner function')
    return inner

print(outer())

output:
-------
this is the outer function
<function outer.<locals>.inner at 0x0000000002D74670>

-->here it returned the function object, the reason is the return value of the outer() is 'inner' which is the function variable. if you print the function variable, it will give you the address. here the inner() is not called, you can call it in the return statement. see below : 

example:
--------
def outer():
    print('this is the outer function')
    def inner():
        print('this is the inner function')
    return inner()

print(outer())

output:
-------
this is the outer function
this is the inner function
None

-->here it returns the 'None', the reason is the inner function is not returning anything. if the functions is not returnig anything it's return value is None. 

-->let's taka look at the sample decorator : 

example:
--------
def decorator(func):
    print('this is the decorator function')
    def inner():
    	
        print('this is the inner function')
        func()
        
    return inner

@decorator
def main():
    print("this is the main function ")

main()

output:
-------
this is the decorator function
this is the inner function
this is the main function 

-->here the we have the decorator function 'decorator'. main() is the decorated function. the 'decorator' function takes the 'main' as the argument. her func = main. the reason why we have the 'inner' function is, it called the 'main' function.

-->actually this is the new style of implementing the function decorators. before '@' was introduced, there is another way to invoke the decorators. see below : 

example:
--------
def decorator(func):
    print('this is the decorator function')
    def inner():    	
        print('this is the inner function')
        func()
        
    return inner


def main():
    print("this is the main function ")

main = decorator(main)

main()

output:
-------
this is the decorator function
this is the inner function
this is the main function 

-->here instread of using the '@' symbol, we invoked the decorator in the old style. here 'decorator(main)' calls the decorator function with 'main' as the argument. the return value of the 'decorator(func) is 'inner'. now the main is point to the 'inner'. so when you call the main(), it calls the inner() functions.

-->we can decorator many functions using the single decorator. see below : 

exmaple:
--------
def decorator(func):
    def inner():
        print('this is the function : ', func.__name__)
    return inner

@decorator
def func1():
    print('this is func1')

@decorator
def func2():
    pass

func1()
func2()

output:
-------
this is the function :  func1
this is the function :  func2

-->here we decorated the 2 functions func1 and func2. when you call func1(), func(2), they calls the inner function 2 times. 

-->let's write the above progrma without using the '@decorator'. see below : 

example:
---------
def decorator(func):
    def inner():
        print('this is the function : ', func.__name__)
    return inner


def func1():
    print('this is func1')

func1 = decorator(func1)
func1()


def func2():
    pass

func2 = decorator(func2)
func2()

output:
-------
this is the function :  func1
this is the function :  func2


-->we can write the nested decorators also. see below :
example:
--------
def first_dec(func):
    def inner():
        print('this is the first decorator')
        return func()
    return inner

def second_dec(func):
    def inner():
        print('this is the second decorator')
        return func()
    return inner

@first_dec
@second_dec
def main():
    print('this is the main function')

main()

output:
-------
this is the first decorator
this is the second decorator
this is the main function

-->here the inner decorator executes first, then the outer decorator executes, then finally the main() function is called. let's write this code without using '@decorator'.

example:
--------
def first_dec(func):
    def inner():
        print('this is the first decorator')
        return func()
    return inner

def second_dec(func):
    def inner():
        print('this is the second decorator')
        return func()
    return inner

def main():
    print('this is the main function')

main = first_dec(second_dec(main))

main()

output:
-------
this is the first decorator
this is the second decorator
this is the main function


@wraps:
-------
-->there is one flaw in code written above. see below : 

example:
--------
def decorator(func):
    def inner():
        print('this is the inner function : ', func.__name__)
        func()
    return inner

@decorator
def main():
    print('this is the main function')

main()
main()

output:
-------
this is the inner function :  main
this is the main function
this is the inner function :  main
this is the main function

-->here every time we call the main() function, it is not calling the main() function, it is called the inner() function. the reason is the main function variable 'main' is pointing to the inner() function variable 'inner'. but this is not how it should be. the function variable 'main' should always pointing to it's function main(). so avoid that we have to use the other decorator '@wraps' from the 'functools' module. see below : 

example:
--------
from functools import wraps
def decorator(func):
    @wraps(func)
    def inner():
        print('this is inner function : ', func.__name__)
        func()
    return inner

@decorator
def main():
    print('this is the main function')

main()

-->For the decorator '@wraps(func)', we have to pass the function variable for which we want to do dereferencing. here the 'func' contains 'main', so @wraps(func) make the referencing, so that after the execution of the above code main is no longer points to the 'inner' function. 
'

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


										       04-01-2022
											----------

class decorators:
-----------------
-->a decorator can not only be a function, it can also be a class. when compared to the execution flow, the class decorators are bit different from the function decorators. see below :

example:
--------
class entry_exit():

    def __init__(self, f):
        self.f = f

    def __call__(self):
        print('entering into the ', self.f.__name__)
        self.f()
        print('exiting the function', self.f.__name__)

@entry_exit
def func1():
    print('inside func1')

@entry_exit
def func2():
    print('inside func2')

func1()
func2()

-->here when the control hits the '@entry_exit', it calls the '__init__()' constructor, with function variable 'func1' as the argument. so in the __ini__(self, f), f contains the 'func1'. the samething applicable for the function 'func2'. when func1() and func2() is called, internally '__call__()' method will be called, here we override the dunder __call__() method. this method will call the main functions 'func1' and 'func2'. 

-->while working with the functiond decorators, we invoked the decorator without using the '@' syntax. for the class decorators also we can invoke them without using the '@'. see below : 

example:
--------
class Entry_exit():

    def __init__(self, f):
        self.f = f

    def __call__(self):
        print('before the function : ', self.f.__name__)
        self.f()
        print('after the function : ', self.f.__name__)

def func1():
    print('this is the func1')

func1 = Entry_exit(func1)

def func2():
    print('this is the func2')

func2 = Entry_exit(func2)

func1()
func2()

output:
-------
before the function :  func1
this is the func1
after the function :  func1
before the function :  func2
this is the func2
after the function :  func2


-->the reason why the class decorator class the __init__() method is, the syntax 'func2 = Entry_exit(func2)', here the 'Entry_exit(func2)', is like the object instantiation syntax. so when instantiation happens, it calls the __init__() constructor immediately.

-->here the syntax 'func1 = Entry_exit(func1)', you may get the doubt that, func1 could be the object. actually here func1 represents the object as well as the function variable. so here 'self' represents the object as well as the function variable. so you can call like 'self()'. it dont' give error, but it goes into the infinite loop. because every time you call self(), it calls the __call__() method, again self() is called, again __call__() is executed. so avoid this practice. see below code : 

example:
--------
class Entry_exit():

    def __init__(self, f):
        self.f = f

    def __call__(self):
        print('before the function : ', self.f.__name__)
        self()
        print('after the function : ', self.f.__name__)

def func1():
    print('this is the func1')

func1 = Entry_exit(func1)

def func2():
    print('this is the func2')

func2 = Entry_exit(func2)

func1()
func2()

-->this code goes into infinite loop.


decorators with arguments:
--------------------------
-->we can pass the arguments to the function decorators. for writing the decorators with arguments, you need to have 2 inner functions. see below : 

example:
--------
import random
def power_of(exponent):
    def decorator(func):
        def inner():
            return func() ** exponent
        return inner
    return decorator

power = int(input('enter the exponent : '))

@power_of(power)
def random_odd_digit():
    return random.choice([3,5,7])

print(random_odd_digit())

output:
-------
enter the exponent : 2
9

-->here the reason why we have 3 functions in the decorator is, the outer function will take the argument, next the decorator function takes the function as the argument and the inner function is used to call the main function or decorated function. let's write the above code without using the '@' syntax : 

example:
---------
import random
def power_of(exponent):
    def decorator(func):
        def inner():
            return func() ** exponent 
        return inner
    return decorator

power = int(input('enter the exponent : '))

def random_odd_digit():
    return random.choice([3,5,7])

random_odd_digit = power_of(power)(random_odd_digit)

print(random_odd_digit())


builtin decorators:
-------------------
-->we previously used the built in decorators like @classmethod, @staticmethod. let's see how we can use them. the normal way of using them is using the '@' syntax. see below :

example:
--------
class A:

    @classmethod
    def hello(cls):
        return f'this is the static method'

print(A.hello())

output:
-------
this is the static method

-->let's write the above code without using '@' syntax. see below :

example:
--------
class A:
    
    def hello(cls):
        return f'this is the static method'

A.hello = classmethod(A.hello)
print(A.hello())

output:
--------
this is the static method

-->let's try the @staticmethod. see below 

example:
--------
class A:
    
    def hello():
        return f'this is the static method'

A.hello = staticmethod(A.hello)
print(A.hello())

output:
-------
this is the static method



task:
-----
s = 'AAABCADDE'

k = 3

value = len(s) //  k

print(value)


list1 = [[] for i in range(k)]

for i, j in zip(range(0, len(s), value), range(k)):
    for ch in s[i : i + value ]:        
        list1[j].append(ch)
    
print(list1)

list2 = [[] for i in range(k)]
for i in range(len(list1)):
    for j in list1[i]:
        if j not in list2[i]:
            list2[i].append(j)

for i in list2:
    print(''.join(i)) 


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


                                                05-01-2022
                                                ----------

requiremnt :
-------------
-->take a string, generate all combinations of the substring. the substring should not have the duplicate characters. return the longest substring which don't have the duplicate characters.

solution:
---------
string = 'abdfdddgee'


set1 = set()
length = len(string)

for i in range(length + 1):
    for j in range(i, length + 1):
        set1.add(string[i : j ])


set1.remove('')
print(set1)

set2 = set()
for i in set1:
    result = ''
    for j in i:
        if j in i and i.count(j) == 1:
            result = result + j
            set2.add(result)
            
print(set2)

dict1 = dict()

for i in set2:
    dict1[i] = len(i)

count = max(dict1.values())
print(count)

for key, value in dict1.items():
    if value == count:
        print(key)



files:
------
-->to work with files we use method open() to open the files. by default the open() method opens the file in teh read mode. the open() method return the file object. see below :

example:
--------
print(open('sample.txt'))

output:
-------
<_io.TextIOWrapper name='sample.txt' mode='r' encoding='cp1252'>

-->this file object is iterable. to get the data we can loop over this file object. see below :

example:
--------
f = open('sample.txt')
for i in f:
    print(i)

output:
-------
hello world

this is python

how are you

-->If you check the output, it adds the new line after every line. this is simply putting a new line character after every line. to avod the new line, use the end = ''. see below : 

example:
--------
f = open('sample.txt')
for i in f:
    print(i, end = '')

output:
-------
hello world
this is python
how are you

-->if you use the open() method, we have to close the file manually usign the method close(). once the file is closed, we can access the file object, but we can't loop over the file object. see below :

example:
--------
f = open('sample.txt')
for i in f:
    print(i, end = '')

f.close()

for i in f:
    print(i)

output:
-------
hello world
this is python
how are youTraceback (most recent call last):
  File "C:\Users\this\Desktop\sample1.py", line 7, in <module>
    for i in f:
ValueError: I/O operation on closed file.


-->to check if the file is closed or not closed, we can use the file attribute 'closed'. this returns true or false. see below : 

example:
--------
f = open('sample.txt')
for i in f:
    print(i, end = '')
    
print('\n',f.closed)

f.close()

print('\n', f.closed)

output:
-------
hello world
this is python
how are you
 False

 True

 -->to read the data from the file object, we have some other methods read(), readline(), readlines().

 read():
 -------
 -->the read() method reads the whole data at once.

 example:
 --------
f = open('sample.txt')
print(f.read())

output:
-------
hello world
this is python
how are you

-->if you loop over the f.read(), you will get the data character by character. see below :

example:
--------
f = open('sample.txt')
for i in f.read():
    print(i)

output:
-------
h
e
l
l
o
 
w
o
r
l
d

-->the reason why this printing character by character is, the read() method reads all data at once in the form of string. if you loop over a string, you will get the each individual character from the string. 


readline():
------------
-->the readline() method reads the one line at a time. see below :

example:
--------
f = open('sample.txt')
print(f.readline())

output:
-------
hello world

>>>

-->Here it print the new line after the line. the reason the readline() add the new line character at the end of the line it reads. to get all the data, we can't write this statement again and again. for that we the method readlines():

readlines():
------------
-->the readlines() method reads the all the data line by line and add them into the list. see below :

example:
--------
f = open('sample.txt')
print(f.readlines())

output:
-------
['hello world\n', 'this is python\n', 'how are you']

-->here each line is stored as the item of list in the string format. it adds the new line character at the end of the each line. when it finds the last line it don't add the new line. to get the individual line use the for loops. see below : 

example:
--------
f = open('sample.txt')
for i in f.readlines():
    print(i)

output:
-------
hello world

this is python

how are you


-->with these 3 methods, we can read how many characters we want using the attribute 'size'. see below :

example:
--------
f = open('sample.txt')
print(f.read(10))

output:
-------
hello worl

-->here I readed the first 10 characters from the file. by default the size = -1, which means all the data.

-->the the problem with the open() method is we have to close the file manually every time we open the file. To avoid that we use the context managers. any statement the contains the 'with' is the context manager. so that when we exit the with block,it automatically close the file connection. it also works with socket connections also. 

example:
--------
with open('sample.txt') as f:
    for i in f.readlines():
        print(i)

output:
-------
hello world

this is python

how are you




-------------------------------------------------------------------------------------------------------------


                                            06-01-2022
                                            ----------


writing the data into the file:
-------------------------------
-->to write the data into the file we need to open the file the write mode, where we have mention like mode = 'w'.

example:
--------
with open('sample.txt', mode = 'w') as f:
    f.write('this is the new line')


-->this opens the file in the write mode and write the line'this is the new line' into the file. if we try to print the result of this operation it simply prints the number of characters it writes into the file. see below : 

example:
--------
with open('sample.txt', mode = 'w') as f:
    print(f.write('this is the new line'))

output:
-------
20

-->here it prints 20, because it writes 20 characters into the file. the write operation return the integer values. but while writing it removes the data and overrides the existing data. at that time open the file in the append mode.

-->once we open the file in the write mode, we can't read that file. we can only write into the file. otherwise we get the error. see below :

example:
--------
with open('sample.txt', mode = 'w') as f:
    print(f.write('this is the new line'))
    print(f.read())

output:
-------
20
Traceback (most recent call last):
  File "C:\Users\this\Desktop\sample1.py", line 3, in <module>
    print(f.read())
io.UnsupportedOperation: not readable


-->if we want to open the file in both read and write mode use mode = 'r+'. see below :

exmaple:
--------
f = open('sample.txt', mode = 'r+')
print(f.write('new line added'))
print(f.read())

output:
-------
14
w line

-->here this write the 14 characters, so it returns 14. But when we read the data it just prints 'w line'. the reason is , previously  have another line 'this is the new line', this is overridden by the new line 'new line added'. since the previous line is big, the 'new line added' was not able to override previous line. but it overridden till 14 character and cursor was waiting at the 14th character. so when we read the file, the cursor was at 14th character, when read it, it is printing the data which is after the 14th character.


-->to know exactly where the cursor is pointing, we use the method tell(). this returns the integer. see below :

example:
--------
f = open('sample.txt', mode = 'r+')
print(f.write('new line added'))
print(f.tell())

output:
-------
14
14

-->here it returns the 14, because the cursor is waiting at the 14th position. we can use the seek() method to cursor whevever we want. this means we can customize the reading position. see below : 

example:
--------
f = open('sample.txt', mode = 'r+')
print(f.write('new line added'))

f.seek(0)

print(f.read())

output:
-------
14
new line addedw line

-->here seek(0) means, put the reading position at the start. the return value of the seek() method is an integer. which means it returns at which character it is placing the cursor. see below : 

example:
--------
f = open('sample.txt', mode = 'r+')
print(f.write('new line added'))

print(f.seek(0))
print(f.read())

print(f.seek(5))
print(f.read())

output:
-------
14
0
new line addedw line
5
ine addedw line


writing from a file:
--------------------
-->we can read the data from a file and write that data into anothe file. for that we need to open the 2 files. see below : 

example:
--------
with open('sample.txt') as f:
    with open('sample1.txt', mode = 'r+') as g:
        g.write(f.read())
        print(g.read())

output:
-------


-->here I read the data from file sample.txt and write that data into sample1.txt. then I read the data from the file sample1.txt, but it is not printing anything. the reason is , the cursor position is at the end of the file. so read from the begining just use the seek(0), then read the file. see below :

example:
--------
with open('sample.txt') as f:
    with open('sample1.txt', mode = 'r+') as g:
        g.write(f.read())
        g.seek(0)
        print(g.read())

output:
-------
hello world
this is python


-->here we can use the methods readline() and readlines() also.


appending the data:
-------------------
-->previously when we writing into the file, it is overriding the data. to avoid that we use mode = 'a', where it adds the new at the end of the existing data. see below : 

example:
--------
with open('sample.txt', mode = 'a+') as f:
    f.write('this is the new line')
    print(f.read())

output:
-------


-->this also returns nothing. becuase it appends the new line at end of the file, so cursor is again at the end of the line. so use seek(0). see below : 

example:
--------
with open('sample.txt', mode = 'a+') as f:
    f.write('this is the new line')
    f.seek(0)
    print(f.read())

output:
-------
hello world
this is python
this is the new line


exclusive mode:
---------------
-->when you open a non existing file in exclusive mode, it creates a new file, it the file already exists, it returns error. see below : 

example:
--------
with open('sample2.txt', mode = 'x') as f:
    print(f)

output:
-------
<_io.TextIOWrapper name='sample2.txt' mode='x' encoding='cp1252'>

-->here there is not file named 'sample2.txt', so it creates the new file and the operation is successful. if we run this code for the second time, it throws the exception. 

example:
--------
with open('sample2.txt', mode = 'x') as f:
    print(f)

output:
-------
Traceback (most recent call last):
  File "C:\Users\this\Desktop\sample1.py", line 1, in <module>
    with open('sample2.txt', mode = 'x') as f:
FileExistsError: [Errno 17] File exists: 'sample2.txt'



-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



 									08-01-2022
                                            				----------

Exceptions:
-----------
-->exceptions are the run time error. even though the syntax is correct, due to some logical error, it will stops the execution and raises the exception. examples are like ZeroDivision, StopIteration, ArithmeticError etc.

example:
--------
print(10/0)

output:
-------
Traceback (most recent call last):
  File "C:\Users\this\Desktop\sample1.py", line 1, in <module>
    print(10/0)
ZeroDivisionError: division by zero

-->here this raise the zerodivisionerror, because anything divide with zero is infinity. In exceptions we have 3 blocks. 

1)try
2)catch
3)finally

-->whatever the block of code or statement might causing the exception, we write that block of code in the try block. it any exception is raised it will be catched in the 'catch' block. the 'finally' block will executes irrelavent of wether the exception is raised or not. 'finally' block is useful tell you that you reached the end of the excecution. 

-->let's catch the zerodivisionerror exception : 

example:
--------
try:
    print(10/0)

except ZeroDivisionError:
    print('exception is raised')

output:
-------
exception is raised


-->here we used the relavent exception. what if we don't know the exact exception, use the parent exception "Exception". see below :

example:
--------
try:
    print(10/0)

except Exception:
    print('exception is raised')

output:
-------
exception is raised

-->here there is a problem with this. we don't know the exactly what kind of exception we are getting. at that time use the 'Exception' class object. see below :

example:
--------
try:
    print(10/0)

except Exception as e:
    print('exception is raised is : ', e)

output:
-------
exception is raised is :  division by zero


multiple except blocks:
-----------------------
-->we can write the multiple 'except' blocks. so that the relavent exception will catched. see below : 

example:
--------
string = 'hello'

try:
    value = int(string)

except TypeError:
    print('type of string is incopatible')

except ValueError:
    print('only accepts the integer')

finally:
    print('finished execution')

output:
-------
only accepts the integer
finished execution

-->here the first exception is not catched, second exception is catched. there is another way to write the above code. see below : 

example:
--------
string = 'hello'

try:
    value = int(string)

except (TypeError, ValueError):
    print("enter the correct value")

output:
-------
enter the correct value


-->The problem with this is, we don't know exactly which exception it is catching. if you want to know which exception is raising, us the 'as' keyword to get the exception object. see below :

example:
--------
string = 'hello'

try:
    value = int(string)

except (TypeError, ValueError) as e:
    print(e)
    print(type(e))
    print("enter the correct value")

output:
-------
invalid literal for int() with base 10: 'hello'
<class 'ValueError'>
enter the correct value


-->if you print the exception object it simply prints the exception message. to know which exception is raised exactly, just use type(e). the reason is 'e' will the object of the exception which is raised. so if print the type of that object, it will simply returns it's class name(exception name).


exceptions hierarchy:
---------------------
-->always write the subclass exceptions at the begining and the super class excpetions at the end in a hierarchical manner. see the below 

example:
--------
x = 10
y = 'string'
try :

    result = x / y

except ZeroDivisionError as zde:
    print(type(zde), zde)

except ValueError as ve:
    print(type(ve), ve)

except Exception as e:
    print('super class exception is called')
        
output:
-------
super class exception is called

-->here when there is no relevant exception is catched, the super class excpetion 'Exception' catches that exception. if we write the super class exception at the begining it catches all the exceptions. control never goes to the other exceptions in the block. see below : 

example:
--------
x = 10
y = 0
try :

    result = x / y
    
except Exception as e:
    print('super class exception is called')

except ZeroDivisionError as zde:
    print(type(zde), zde)

except ValueError as ve:
    print(type(ve), ve)


output:
-------
super class exception is called


-->here the syntax 'result = x / y' raises the 'zerodivisionerror', even though the we have provided the relavent exception, it was caught by the super class 'Exception'. so whatever the exception is raised it will be caught by the super class 'Exception' in the early stages. to make this program more readable, use the object of the exception class. see below : 

example:
--------
x = 10
y = 0
try :

    result = x / y
    
except Exception as e:
    print('super class exception :', e)

except ZeroDivisionError as zde:
    print(type(zde), zde)

except ValueError as ve:
    print(type(ve), ve)

output:
-------
super class exception : division by zero


Aliasing:
---------
-->notice the following line in the code above :

except (exception 1, excpetion 2, ..) as e:

-->that is the exceptions are being given a name. technically, it is called 'aliasing'. with aliasing, we can access the exceptions with a common name. this is useful if you want to use attributes of the exception being handled. aliasing is done through the 'as' keyword. the syntax is : 

try : 
    # try code

except (exception_1, exception_2,..) as <alias>:

    # exception handling here
    # you can access attributes of exceptions being handled through it's alias <alias>


example:
--------
try:
    raise NameError('undefined name')

except (NameError, ValueError) as er:
    print('NameError exception was raised')

output:
-------
NameError exception was raised

-->you can use any name for the alias(but definitely not the built-in keyword), usually 'e' is just a popular one.


Finally clause:
---------------
-->the 'try' statement has one last clause 'finally', which is basically used for clean up actions. when used, it should follow all other clauses. 'finally' clause is executed in any even irrespective of whether an exception has occurred or not. 'finally' clause does not strictly need to the 'else' or 'except' clause to be present. see below : 

example:
--------
def func(a, b):
    try:
        output = a / b

    except ZeroDivisionError:
        print('zerodivisionerror raised')

    else :
        print('the result is  : ',output)

    finally:
        print('program ended')

func(10, 0)
func(10, 2)

output:
-------
zerodivisionerror raised
program ended
the result is  :  5.0
program ended







patterns:
---------
-->print the below patterns

a
a c
a c e
a c e g

solution:
---------
list1 = [chr(i) for i in range(97, 104)]
print(list1)

for i in range(0, len(list1), 2):
    print(' '.join(list1[0 : i + 1 : 2]))


-->print the below pattern
[1]
[1][2]
[1][2][3]
[1][2][3][4]
[1][2][3][4][5]

solution:
---------
for i in range(1, 6):
    print()
    for j in range(1, i + 1):
        print(f'[{j}]', end = '')


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




requirement:
------------
you are given a string S of size N. you need to find the number of subsequences of string S that can be made palindrome by rearranging. Since the answer can be large return it moduel 10 **(9 + 7).

Note : 
------
S only contains lowercase english alphabets. an empy sebsequence is always a palindrome.

input format:
--------------
-->the first line contains an integer, N, denoting the size of the string A.
-->The next line contains a string, S, denoting the string S.

sample input:
-------------
bb --> result should be 4
bab --> result should be 6
aaccb --> result should be 16

solution:
---------

string = 'aaccb'
list1 = ['']
import itertools as it

for i in range(1, len(string) + 1):
     for j in it.combinations(string, i):
         for k in set(it.permutations(j)):
            result = ''.join(k)
            print(result)
            if result == result[::-1]:
                list1.append(result)

for i in list1:
    if len(i) > 2:
        if list1.count(i) > 1:
            list1.remove(i)

print(list1, len(list1))



requirement 2:
--------------

solution :
----------
import itertools as it
list1 = [1,3,2,5]

n = 2

for i in it.combinations(list1, n):
    print(i)



Generators:
-----------
-->before we go with generators, we need to understand the iterable and iterators.

iterable : iterable is any object we iterate over it using the for loop. they are not always indexible. sometimes they are finite, sometimes they are infinite.

-->Here's is infinite iterable which provides every multiple of 5 as you loop over it.

example:
--------
from itertools import count
result = count(step = 5)
print(result)

output:
--------
count(0, 5)

-->here this returns iterator object which can be iterable. if we use the for loop to get the elements from this, it goes into the infinite loop.

example:
--------
from itertools import count
result = count(step = 5)
print(result)

#this causes the infinite loop.
for i in result:
    print(i)


-->to avoid that use the loop variable or condition to control the incrementation. see below : 

example:
--------
from itertools import count
result = count(step = 5)
print(result)

for i in result:
    if i <= 40:
        print(i)

output:
-------
count(0, 5)
0
5
10
15
20
25
30
35
40


iterators:
----------
-->Iterator is an object used to iterator over the iterable objects like list, set, string, dictionary. The iterator object is initialized using the iter() method. This method raises the 'StopIteration' exception to signal the end of the iteration. let's create one iterator. see below : 

example:
--------
result = iter(['hello', 'world'])

print(result)

print(next(result))
print(next(result))

output:
-------
<list_iterator object at 0x0000000002D02EB0>
hello
world

-->here I passed the iterable to an iter() method to create the iterator. we can say iterator are the object which we can loop over or use the next() method to get the element from the. so all the iterators are iterables. if there is no elements in the iterator to read, it raises the StopIteration exception. see below:

examaple:
---------
result = iter(['hello', 'world'])

print(result)

print(next(result))
print(next(result))
print(next(result))

output:
-------
<list_iterator object at 0x0000000002D01EB0>
hello
world
Traceback (most recent call last):
  File "C:\Users\this\Desktop\sample1.py", line 7, in <module>
    print(next(result))
StopIteration


-->sometimes use the for loops for the iterators. because they handle the StopIteration exceptions in some occasions. see below : 

example:
--------
<list_iterator object at 0x0000000002D02EB0>
hello
world








requirement : 
--------------
-->given a list of elements, find the triplets where the sum of all elements in that triplets is 0.

solution:
----------
lst = [-1, 0, 1, 2, -1, -4]
#output = [[-1, -1,2], [-1, 0, 1]]

length = len(lst)
result = []

for i in range(length):
    for j in lst[i+1 : ]:
        for k in lst[j + 1 : ]:
            if i + j + k == 0:
                result.append([i, j, k])

print(result)

output:
-------
[[0, 0, 0], [0, 1, -1], [0, -1, 1], [1, -1, 0], [2, 2, -4], [2, -1, -1], [2, -1, -1], [2, -4, 2]]


solution 2:(not complete solution)
-----------
import itertools as it

list1 = []

for i in it.combinations(lst, 4):
    print(i)
    if sum(i) == 0:
        
        list1.append(i)

print(list1)

output:
-------
[(-1, 0, 1), (-1, 2, -1), (0, 1, -1)]



-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




                                                11-01-2022
                                                ----------


Generators:
-----------
-->Generators are iterators, a kind of iterable you can only iterate over once. Generators do not store all the values in memory, they generate the values on the fly. we can create the generator object using the tuple comprehensions. see below : 

example:
--------
result = (i for i in range(1,6))

print(result)

output:
-------
<generator object <genexpr> at 0x0000000002D00F20>


-->to get the values from the generator use next() method or use for loop. see below : 

example:
--------
result = (i for i in range(1,6))

print(result)

for i in result:
    print(i)

output:
-------
<generator object <genexpr> at 0x0000000002D01F20>
1
2
3
4
5


-->once we access all the elements of the generator, we can't access them for the second time. let's try : 

example:
--------
result = (i for i in range(1,6))

print(result)

for i in result:
    print(i)

print(next(result))


output:
-------
<generator object <genexpr> at 0x0000000002D01F20>
1
2
3
4
5
Traceback (most recent call last):
  File "C:\Users\this\Desktop\sample1.py", line 8, in <module>
    print(next(result))
StopIteration

-->here this code raised the stopiteration exception, this means it reaches end of it. at this time we have to use the exceptions.


yield:
------
-->any function which contains the 'yield' keyword, that function call will create a generator object. see below :

example:
--------
def func():
    yield 'hello world'

a = func()
print(type(a))

output:
-------
<class 'generator'>

-->here 'a', we can call it as the generator object or generator instance. see here that type(a) is class generator. here a = func(), this don't call the function, it just create the generator object. don't think a = func() will create the function variable. if you want to start the execution, you should use the next() method. it will start the execution of generator function. see below : 


example:
--------
def func():
    yield 'hello world'

a = func()
print(next(a))

output:
-------
hello world


-->yield is just like the 'return' statement. but after 'return' no statement is execute, but for 'yield', it saves the state of the execution and return the control back to it's caller. 

multiple yield statements:
--------------------------
-->we can write the multiple yield statement in single function. see below : 

example:
--------
def func():
    yield 1
    yield 2
    yield 3

result = func()
print(next(result))
print(next(result))
print(next(result))

output:
-------
1
2
3

-->we can't write the generators like below : 

example:
--------
def func():
    yield 1
    yield 2
    yield 3

print(next(func()))
print(next(func()))
print(next(func()))

output:
-------
1
1
1

-->the reason why this is printing the 1 again and again is, here with the syntax func(), we are creating the new generator instance every time. so if we perform the next() on each new object, they start the executing from the begining. 


-->just like the empty return statement return 'None', the same way the empty 'yield' returns 'None'. see below : 

example:
--------
def func():
    return

print(func())

output:
-------
None


example:
--------
def func():
    yield

result = func()
print(next(result))

output:
-------
None

-->see here if the yield is not returning anything, by defualt it returns 'None'. 


send():
-------
-->we can send the values to the generator and we can only call the send(), it generator is started. see below : 

example:
--------
def func():
    value = yield
    yield value

result = func()
print(next(result))
print(result.send('hello'))

output:
-------
None
hello

-->here the empty yield return 'None', the we send the value to the yield, then value contains 'hello', then the next 'yield' is executed and prints the 'hello'. if we don't the generator and simply sends a data to it, it will be a error. see below : 

example:
--------
def func():
    value = yield
    yield value

result = func()
print(result.send('hello'))

output:
-------
Traceback (most recent call last):
  File "C:\Users\this\Desktop\sample1.py", line 6, in <module>
    print(result.send('hello'))
TypeError: can't send non-None value to a just-started generator


-->here it say you can' send non-None value to a just-started generator. so this means we can send a 'None' value to a just started generator. see below : 

example:
--------
def func():
    value = yield
    yield value

result = func()
print(result.send(None))

output:
-------
None


-->let's send the data 2 times. see below : 

example:
--------
def func():
    value = yield
    yield value

result = func()
print(next(result))
print(result.send('hello'))

print(next(result))
print(result.send('world'))

output:
-------
None
hello
Traceback (most recent call last):
  File "C:\Users\this\Desktop\sample1.py", line 9, in <module>
    print(next(result))
StopIteration


-->here I tried to send the data 2 times, but it raised the exception. to avoid that use the while loop. see below code :

example:
--------
def func():
    while True:
        value = yield
        yield value

result = func()
print(next(result))
print(result.send('hello'))

print(next(result))
print(result.send('world'))

output:
-------
None
hello
None
world


returning a function using yield:
---------------------------------
-->not only a value, we can also return a function using the yield statement. see below : 

example:
--------
def func():
    yield even_numbers()

def even_numbers():
    return [i * 2 for i in range(1, 11)]

result = func()
print(next(result))

output:
-------
[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

-->here I am returning a function using the yield statement. 


yield with exceptions:
----------------------
-->when there is no elements to read, it raises the stopiteration exception. see below :

example:
--------
def func():
    for i in range(5):
        yield i

result = func()

for i in range(6):
    print(next(result))

output:
-------
0
1
2
3
4
Traceback (most recent call last):
  File "C:\Users\this\Desktop\sample1.py", line 8, in <module>
    print(next(result))
StopIteration


-->let's handle this exception using try, catch : 

example:
--------
def func():
    for i in range(5):
        yield i

result = func()

try:
    for i in range(6):
        print(next(result))

except StopIteration as e:
    print('exception is ', type(e))

finally:
    print('execution finished')

output:
-------
0
1
2
3
4
exception is  <class 'StopIteration'>
execution finished


yield from:
-----------
-->'yield from' is used to return the data from the iterable in a simple way. see below : 

example:
--------
def func(x, y):
    yield from x
    yield from y

a = [1,2,3]
b = [4,5,6]

for i in func(a,b):
    print(i)

output:
-------
1
2
3
4
5
6

-->if you write the same code without using the yield, it will be like this :

example:
--------
def func(x, y):
    for i in x:
        yield i

    for j in y:
        yield j

a = [1,2,3]
b = [4,5,6]

for i in func(a,b):
    print(i)

output:
-------
1
2
3
4
5
6


-->we can return multiple values using yield. see below :

example:
--------
def func():
    for i in range(1,6):
        yield i, i ** 2

for i, j in func():
    print(i, j)

output:
-------
1 1
2 4
3 9
4 16
5 25

-->here the yield is returning 2 values at a time, to read those 2 values we need 2 loop variables.




-------------------------------------------------------------------------------------------------------------

        
                                                    12-01-2022
                                                    ----------

what is OOP:
------------
-->Object Oriented programming (OOP) is a programming paradigm that relies on the concept of classes and objects. It is used to structure a software program into simple, reusable pieces of code blueprints (usually called classes), which are used to create individual instances of objects. 

class and instance:
-------------------
-->classes are used to create user-defined data structures. classes define functions called 'methods', which identify the behaviour and actions that an object created from the class can perform with its data. 


singleton classes:
------------------
-->Singleton is a creational design pattern, which ensures that only one object of its kind exists and provides a single point of access to it for any other code.


constructor:
------------
-->The constructor is a method that is called when an object is created. This method is defined in the class and can be used to initialize basic variables.

-->Instance methods are functions that are defined inside a class and can only be called from an instance of that class. Just like .__init__(), an instance methods first parameter is always self. by default all the methods in the class are instance methods.

example:
--------
class HelloWorld(object):

    def __init__(self, message):
        self.message = message

    def display(self):
        print(self.message)

s1 = HelloWorld('hi')
s2 = HelloWorld('hello')
s3 = HelloWorld('whats up')

s1.display()
s2.display()
s3.display()

output:
-------
hi
hello
whats up


-->here the method display() is the instance method. the instance method is called with the object name and also it recievs the object name as it's first argument. we can also call the instance method directly with the constructor syntax. we can write the above program in another way : 

example:
--------
class HelloWorld(object):

    def __init__(self, message):
        self.message = message

    def display(self):
        print(self.message)

HelloWorld('hi').display()
HelloWorld('hello').display()
HelloWorld('whats up').display()

output:
-------
hi
hello
whats up

-->here with the constructor syntax, we created the object and passed value to the '__init__()' and called the method display(). but this is not a good practice. because this is called as the anonymous objects. we can't use them anywhere.


delete the instance method:
---------------------------
-->here I tried to delete the instance method using the object outside the class. see below : 

example:
--------
class HelloWorld(object):

    def __init__(self, message):
        self.message = message

    def display(self):
        print(self.message)    

s1 = HelloWorld('hi')
s2 = HelloWorld('hello')
s1.display()

del s1.display

output:
-------
hi
Traceback (most recent call last):
  File "C:\Users\this\Desktop\sample1.py", line 13, in <module>
    del s1.display
AttributeError: display

-->here it is giving the attribute error. which means the object s1 has no attribute 'display'. so if you want to delete the instance method, delete them using the class name. see below :

example:
---------
class HelloWorld(object):

    def __init__(self, message):
        self.message = message

    def display(self):
        print(self.message)    

s1 = HelloWorld('hi')
s2 = HelloWorld('hello')
s1.display()

del HelloWorld.display

output:
-------
hi

-->here it don't return error. because it simply deleted that method. we can only delete the instance method using the class name.


class method:
-------------
-->A class method is a method which is bound to the class and not the object of the class. They have the access to the state of the class as it takes a class parameter that points to the class and not the object instance. It can modify a class state that would apply across all the instances of the class. 
-->for class methods, we call them using the class name and the class object also. 

example:
--------
class HelloWorld(object):

    message = 'hello world'

    def print_message(cls):
        print(cls.message)
        
HelloWorld.print_message()


output:
-------
Traceback (most recent call last):
  File "C:\Users\this\Desktop\sample1.py", line 8, in <module>
    HelloWorld.print_message()
TypeError: print_message() missing 1 required positional argument: 'cls'

-->Normally class method takes the class name as the argument. but here it returns the error. But here we need to mention the method as the class method using the @classmethod decorator. see below : 

example:
--------
class HelloWorld(object):

    message = 'hello world'

    @classmethod
    def print_message(cls):
        print(cls.message)
        
HelloWorld.print_message()
output:
-------
hello world


-->we can access the class variable using both class name and object name.

example:
--------
class HelloWorld(object):

    message = 'hello world'

    def __init__(self, name):
        self.name = name        

    @classmethod
    def print_message(cls):
        print(cls.message)
        
obj = HelloWorld('venkat')
obj.print_message()

print(obj.message)
print(HelloWorld.message)

output:
-------
hello world
hello world
hello world


-->if you remember the internal structure of the decorator, then write the decorator @classmethod, in the old style. see below : 
example:
--------
class HelloWorld(object):

    message = 'hello world'

    def printname(cls):
        print(cls.message)

HelloWorld.printname = classmethod(HelloWorld.printname)
HelloWorld.printname()
output:
-------
hello world


static method:
-------------

-->A static method is also a method that is bound to the class and not the object of the class. A static method can't access or modify the class state. It is present in a class because it makes sense for the method to be present in class.

-->Static methods in Python are extremely similar to python class level methods, the difference being that a static method is bound to a class rather than the objects for that class. This means that a static method can be called without an object for that class. This also means that static methods cannot modify the state of an object as they are not bound to it. Lets see how we can create static methods in Python.


creating static method:
-----------------------
class Calculate:   
    
    @staticmethod
    def addition(x,y):
        print('addition is : ', x + y)

Calculate.addition(10, 20)

output:
-------
addition is :  30

-->as we said earlier we can call the static method with class name. we can also call the static method with object also. see below : 

example:
--------
class Calculate:   

    @staticmethod
    def addition(x,y):
        print('addition is : ', x + y)

Calculate.addition(10, 20)

#calling the static method with object
c = Calculate()
c.addition(20, 30)

output:
-------
addition is :  30
addition is :  50


-->if you remember the internal mechanism of the decorators, use the old style decorators to create the static methods using the method "staticmethod()"

example : 
---------
class Calculate:   

    def addition(x,y):
        print('addition is : ', x + y)

Calculate.addition = staticmethod(Calculate.addition)
Calculate.addition(10, 20)

output:
-------
addition is :  30

-->instead of the addition() method, we can give any other names to store the return value of the staticmethod. see below : 

example :
---------
class Calculate:   

    def addition(x,y):
        print('addition is : ', x + y)

Calculate.add = staticmethod(Calculate.addition)
Calculate.add(10, 20)
output:
-------
addition is :  30

-->here the 'add' becomes the function variable and it points to the static method 'addition'.

-->the static method don't have the direct access to the class variables. see below : 

example :
---------
class Calculate:   

    message = 'hello'

    @staticmethod
    def addition():
        print('class variable is : ', message )

Calculate.addition()

output:
-------
Traceback (most recent call last):
  File "C:\Users\this\Desktop\sample1.py", line 9, in <module>
    Calculate.addition()
  File "C:\Users\this\Desktop\sample1.py", line 7, in addition
    print('class variable is : ', message )
NameError: name 'message' is not defined


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




                                            13-01-2022
                                            ----------


                                              Constructors
                                               ------------

-->The constructor is a method that is called when an object is created. this method is defined in the class and can be used to initialize basic varaibles. 

-->if you create four objects, the class constructor is called four times. every class has a constructor, but it's not required to explicitly define it. 

-->the constructor always has the name 'init' and the name init is prefixed and suffixed with a double underscore(__). we declare a constructor using 'def' keyword, just like methods. we are calling this as constructor because this init also constructing the object attributes. 

def __init__(self):
    #body of the constructor

-->usually we default constructor and parameterized constructor.

default constructor:
--------------------
-->even we don't write the constructor, python will write the default constructor for us. see below : 

example:
--------
class Hello():

    def read(self):
        print('this is the read method')

h = Hello()
h.read()

output:
-------
this is the read method

-->python will treat this code as below :

example:
--------
class Hello():

    def __init__(self):
        pass

    def read(self):
        print('this is the read method')

h = Hello()
h.read()


parameterised constructor:
--------------------------
-->when the contructor is accepting the parameters during the creation of the object. see below : 

example:
--------
class Hello():

    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    def read(self):
        print(self.a, self.b, self.c)

h = Hello(10, 20, 30)
h.read()

output:
-------
10 20 30

-->we can also use the default parameters for the constructor also. see below  :

example:
--------
class Hello():

    #constructor with default parameters
    def __init__(self, a = 10, b= 20, c = 30):
        self.a = a
        self.b = b
        self.c = c

    def read(self):
        print(self.a, self.b, self.c)

h = Hello()
h.read()

output:
-------
10 20 30


constructor overloading with default parameters:
------------------------------------------------
-->we can achieve the constructor overloading using the default parameters. see below : 

example:
---------
class Demo():
    num = 101

    def __init__(self, a = 10, b = 20):
        self.a = a
        self.b = b
    
    def read_number(self):
        print(self.a, self.b)

obj = Demo(20)
obj.read_number()

obj1 = Demo(10, 20)
obj1.read_number()

obj2 = Demo()
obj2.read_number()
output:
-------
20 20
10 20
10 20

-->here constructor can be invoked in 3 different ways. that means we are able to call the same constructor in 3 ways. this is called constructor polymorphism.


                                 
Encapsulation
-------------
-->Encapsulation in Python is the process of wrapping up variables and methods into a single entity.In programming, a class is an example that wraps all the variables and methods defined inside it.


Using Single Underscore:
------------------------
-->A common Python programming convention to identify a private variable is by prefixing it with an underscore. Now, this doesnt really make any difference on the compiler side of things. The variable is still accessible as usual. But being a convention that programmers have picked up on, it tells other programmers that the variables or methods have to be used only within the scope of the class.

See the below example:

class Person:
    def __init__(self, name, age=0):
        self.name = name
        self._age = age
 
    def display(self):
        print(self.name)
        print(self._age)
 
person = Person('Dev', 30)
#accessing using class method
person.display()
#accessing directly from outside
print(person.name)
print(person._age)

Output:
------
Dev
30
Dev
30

-->Its clear that the variable access is unchanged. But can we do anything to really make it private? Lets have a look further.

Using Double Underscores:
-------------------------
-->If you want to make class members i.e. methods and variables private, then you should prefix them with double underscores. But Python offers some sort of support to the private modifier. This mechanism is called Name mangling. With this, it is still possible to access the class members from outside it.

Name Mangling:
--------------
-->In Python, any identifier with __Var is rewritten by a python interpreter as _Classname__Var, and the class name remains as the present class name. This mechanism of changing names is called Name Mangling in Python.

-->In the below example, in Class person, the age variable is changed and its prefixed by leading double underscores.

example:
--------
class Person:
    def __init__(self, name, age=0):
        self.name = name
        self.__age = age
 
    def display(self):
        print(self.name)
        print(self.__age)
 
person = Person('Dev', 30)
#accessing using class method
person.display()
#accessing directly from outside
print('Trying to access variables from outside the class ')
print(person.name)
print(person.__age)

Output:
-------
Dev
30
Trying to access variables from outside the class
Dev
Traceback (most recent call last):
  File "Person.py", line 16, in <module>
    print(person.__age)
AttributeError: 'Person' object has no attribute '__age'



Types Of Inheritance:
---------------------
-->In Python, based upon the number of child and parent classes involved, there are five types of inheritance. The type of inheritance are listed below:

1)Single inheritance
2)Multiple Inheritance
3)Multilevel inheritance
4)Hierarchical Inheritance
5)Hybrid Inheritance


Single Inheritance:
-------------------
-->In single inheritance, a child class inherits from a single-parent class. Here is one child class and one parent class.

Example:
--------
-->Lets create one parent class called ClassOne and one child class called ClassTwo to implement single inheritance.

# Base class
class Vehicle:
    def Vehicle_info(self):
        print('Inside Vehicle class')

# Child class
class Car(Vehicle):
    def car_info(self):
        print('Inside Car class')

# Create object of Car
car = Car()

# access Vehicle's info using car object
car.Vehicle_info()
car.car_info()

Output:
------
Inside Vehicle class
Inside Car class


Multiple Inheritance:
---------------------
-->In multiple inheritance, one child class can inherit from multiple parent classes. So here is one child class and multiple parent classes.

Example:
--------
# Parent class 1
class Person:
    def person_info(self, name, age):
        print('Inside Person class')
        print('Name:', name, 'Age:', age)

# Parent class 2
class Company:
    def company_info(self, company_name, location):
        print('Inside Company class')
        print('Name:', company_name, 'location:', location)

# Child class
class Employee(Person, Company):
    def Employee_info(self, salary, skill):
        print('Inside Employee class')
        print('Salary:', salary, 'Skill:', skill)

# Create object of Employee
emp = Employee()

# access data
emp.person_info('Jessa', 28)
emp.company_info('Google', 'Atlanta')
emp.Employee_info(12000, 'Machine Learning')
Output:
--------
Inside Person class
Name: Jessa Age: 28

Inside Company class
Name: Google location: Atlanta

Inside Employee class
Salary: 12000 Skill: Machine Learning

-->In the above example, we created two parent classes Person and Company respectively. Then we create one child called Employee which inherit from Person and Company classes.


Multilevel inheritance:
-----------------------
-->In multilevel inheritance, a class inherits from a child class or derived class. Suppose three classes A, B, C. A is the superclass, B is the child class of A, C is the child class of B. In other words, we can say a chain of classes is called multilevel inheritance.

Example:
--------
# Base class
class Vehicle:
    def Vehicle_info(self):
        print('Inside Vehicle class')

# Child class
class Car(Vehicle):
    def car_info(self):
        print('Inside Car class')

# Child class
class SportsCar(Car):
    def sports_car_info(self):
        print('Inside SportsCar class')

# Create object of SportsCar
s_car = SportsCar()

# access Vehicle's and Car info using SportsCar object
s_car.Vehicle_info()
s_car.car_info()
s_car.sports_car_info()

Output:
-------
Inside Vehicle class
Inside Car class
Inside SportsCar class

-->In the above example, we can see there are three classes named Vehicle, Car, SportsCar. Vehicle is the superclass, Car is a child of Vehicle, SportsCar is a child of Car. So we can see the "chaining of classes".



Hierarchical Inheritance:
--------------------------
-->In Hierarchical inheritance, more than one child class is derived from a single parent class. In other words, we can say one parent class and multiple child classes.

Example:
--------
-->Lets create Vehicle as a parent class and two child class Car and Truck as a parent class.

class Vehicle:
    def info(self):
        print("This is Vehicle")

class Car(Vehicle):
    def car_info(self, name):
        print("Car name is:", name)

class Truck(Vehicle):
    def truck_info(self, name):
        print("Truck name is:", name)

obj1 = Car()
obj1.info()
obj1.car_info('BMW')

obj2 = Truck()
obj2.info()
obj2.truck_info('Ford')
Output:
-------

This is Vehicle
Car name is: BMW

This is Vehicle
Truck name is: Ford


Hybrid Inheritance:
-------------------
-->When inheritance is consists of multiple types or a combination of different inheritance is called hybrid inheritance.

Example:
--------
class Vehicle:
    def vehicle_info(self):
        print("Inside Vehicle class")

class Car(Vehicle):
    def car_info(self):
        print("Inside Car class")

class Truck(Vehicle):
    def truck_info(self):
        print("Inside Truck class")

# Sports Car can inherits properties of Vehicle and Car
class SportsCar(Car, Vehicle):
    def sports_car_info(self):
        print("Inside SportsCar class")

# create object
s_car = SportsCar()

s_car.vehicle_info()
s_car.car_info()
s_car.sports_car_info()




dynamic programing:
-------------------

requirement : 
-------------
-->The Fibonacci numbers are the numbers in the following integer sequence.
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ..

In mathematical terms, the sequence Fn of Fibonacci numbers is defined by the recurrence relation 

solution :
----------
import time

start = time.time()
#fibonacci numbers
n = int(input('enter the number : '))

a = 0
b = 1
count = 0
list1 = []

while count <= n + 1:
    list1.append(a)
    a,b = b, a + b
    count = count + 1
    if count == n + 1:
        print(list1[n])
        break
print(list1)

end = time.time()

print(end - start)


-->we can do the samething using the recursion, which is faster and efficient.

solution :
----------
import time

start = time.time()
def fib(n):
    if n <= 1:
        return n

    if n > 0:
        return fib(n-1) + fib(n-2)

print(fib(9))
end = time.time()

print(end - start)


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



                                                15-01-2022
                                                ----------

Threads:
---------
-->the thread is separate flow of execution. this means that your program will have 2 things happening at once. Threads allows us to run multiple tasks concurrently. Here concurrently means running tasks independently. If I am running task A and I can run the task B, i don't have to wait for the task A to complete. one way of having the tasks to run concurrently is having all your tasks to run parallel, which means simultaneously. when the tasks are running simultaneously, they use multiple CPU cores, one CPU core for each task. However this is the problem in python, this is due to something called the Global Interpreter Lock. The GIL prevents the threads from actually running in parallel and they can use only one processor at a time within a script.

-->to work with the threads we use the package 'threading'. 

example:
--------
import threading

def func():
    print('this is the main function')

t = threading.Thread(target = func, name = 'thread1')

t.start()

output:
-------
this is the main function


-->here we can pass the arguments to the function using the threads. see below : 

example:
--------
import threading
import time

def func(n, name):
    print(f'this is the thread : {name}')

    time.sleep(n)

    print(f'{name} has wake up from sleep')

t = threading.Thread(target = func, name = 'thread1', args = (5, 'thread1'))

t.start()

output:
-------
this is the thread : thread1
>>> 
thread1 has wake up from sleep


-->In this we used the 'Thread' class from the module 'threading' which is threading.Thread. take a look at the syntax of the Thread. 

t = threading.Thread(target = func, name = 'thread1', args = (5, 'thread1'))

target --> this is the function on which we want to execute the thread.
name --> the name of our thread. this is useful when we have lot of thread, we can name them to differentiate. 
args --> argument to our target function, here the target function is 'func'. 


-->here I created the theading object 't'. now the thread has been created, to run a thread we use the method t.start(). In the output the cursor is still waiting at the end of the second line, which means the thread is still running.

-->let's add the more statements to the above program. see what happens.

example:
--------
import threading
import time

def func(n, name):
    print(f'this is the thread : {name}')

    time.sleep(n)

    print('f{name} has wake up from sleep')

t = threading.Thread(target = func, name = 'thread1', args = (5, 'thread1'))

t.start()
print('\nhello world')
print('\nhow are you')

output:
-------
this is the thread : thread1
hello world


how are you
>>> f{name} has wake up from sleep


-->here i just added the 2 print statements to the main program. consider this as the main program and the thread we created as the secondary program. when we run this, the thread is get executed and before the thread is finished executing the program runs the other statements(2 print statements), after 5 seconds the thread will woke up, but meanwhile the program runs the other statements. this is called parallelism or concurrency. Simply we switched to the main program when the thread is sleeping and switched back when the thread is ready(woke up). It's kind of go back and forth.


join():
-------
-->If you wanted your thread to actually finish the entire function before it actually jumps back to the main program or main thread, you can use this join() method. t.join() is actually called as the blocking method or the blocking call. it blocks the interpreter from accessing or executing the main program until the thread finishes it's task. It prevents python from executing any other code from the main program until the thread 't' finishes the executing it's function. what happens is we are not going to print the last 2 print statements until the t.join() unblocks when the thread has finished it's task. when the thread completes it's task , then only we are able to move back to those 2 print statements. 

example:
--------
import threading
import time

def func(n, name):
    print(f'this is the thread : {name}')

    time.sleep(n)

    print('f{name} has wake up from sleep')

t = threading.Thread(target = func, name = 'thread1', args = (5, 'thread1'))

t.start()
t.join()

print('\nhello world')
print('\nhow are you')

output:
-------
this is the thread : thread1
f{name} has wake up from sleep

hello world

how are you



creating and running multiple threads:
--------------------------------------
-->Here we created multiple threads that runs concurrently. 

import threading
import time

def sleeper(n, name):
    print('hi, I am {}, going to sleep \n'.format(name))

    time.sleep(n)
    print('{} has woken up from sleep \n'.format(name))

threads_list = []

start = time.time()
for i in range(5):
    t = threading.Thread(target = sleeper,
                         name = 'thread{}'.format(i),
                         args = (5, 'thread{}'.format(i)))

    threads_list.append(t)
    t.start()
    #print('{} has started'.format(t.name))

for t in threads_list:
    t.join()

end = time.time()

print('time taken : {}'.format(end-start))
print('all five threads have finished their jobs')

output:
-------
hi, I am thread0, going to sleep 
hi, I am thread3, going to sleep 
hi, I am thread1, going to sleep 
hi, I am thread2, going to sleep 
hi, I am thread4, going to sleep 

thread0 has woken up from sleep 
thread3 has woken up from sleep 
thread1 has woken up from sleep 
thread2 has woken up from sleep 
thread4 has woken up from sleep 

time taken : 5.125293016433716
all five threads have finished their jobs

-->here the first for loop creates  5 threads and starts them. In the first for loop thread{}'.format(i) means for each value of i, it creates a threads with names thread0, thread1... thread4. In the second for loop the t.join() will prevent the execution of the other statements. we should not write the join() method immediately after the start() method like

t.start()
t.join()

-->if you write like this each thread will take 5 seconds and total 25 seconds. the t.join() will not allow the other threads to run until the current threads finishes. that is not we wanted. 


example:
--------
import time

def sleeper(n, name):
    print("{} is going to sleep".format(name))
    time.sleep(n)
    print("{} is woke up".format(name))

start = time.time()

for i in range(5):
    sleeper(5, i)

end = time.time()

print("it took {} seconds".format(end-start))

output:
-------
0 is going to sleep
0 is woke up
1 is going to sleep
1 is woke up
2 is going to sleep
2 is woke up
3 is going to sleep
3 is woke up
4 is going to sleep
4 is woke up
it took 25.074434280395508 seconds

-->By this program you know, when we don't use the threads python will run line by line and nothing will run concurrently. When you have threads, the threads will some tasks in the background. when we not doing anything CPU intensive threads are very beneficial. Remember the GIL prevents us from running multiple CPU processes. So whenever we are not doing anything CPU intensive threads can be beneficial. threads are very efficient at using any donwtime or idle time. so when we have one thread waiting for somethinng, we can have antoher thread perform a task. In our example when one thread is sleeping, that is considered idle time, because we were not really using much of the CPU resources. Then python will switch to another thread and then and do some tasks with that thread and if that thread is not doing something we will switch to another thread. 


activeCount():
---------------
-->this method is used to know the number of threads that are active. In python there are 1 or 2 active threads running by default. when we create a thread and start it, then count will be increment by 1. Actually when we are running a program, it will be called a main thread, when we create a new thread using 'threading' it will create another thread. In python when you write a program, there will one thread allocated to run that program as the main thread. see below.

import threading
import time

def func():
    print("ran")
    time.sleep(1)
    print('done')

x = threading.Thread(target = func)
x.start()
print(threading.activeCount())

output:
--------
ran 
3
>>> done

-->Here I didn't used the x.join(). if I use the x.join() after the x.start(), then the thread x is gets executed and finishes it's task and thread x will be ended and the activecount will decremented by 1 and returns the activecount as 2. 


is_alive():
-----------
-->this method is used to check if the thread is still running or not. it returns true if the thread is running, else it returns false. see below : 

example:
--------
import threading
import time

def func():
    print("ran")
    time.sleep(1)
    print('done')

x = threading.Thread(target = func)
x.start()

time.sleep(2)
print(x.is_alive())

output:
-------
ran
done
False


create thread in a function:
----------------------------
-->we can create the thread inside a function and call the other functions. see below :

example:
--------
import threading
import time

def func(n, name):
    print(f"running {name}")
    time.sleep(n)
    print('done')


def func1():
    for i in range(2):
        t = threading.Thread(target = func, args = (2, 'thread' + str(i + 1)))
        t.start()
        t.join()

func1()

output:
-------
running thread1
done
running thread2
done

-->here I am calling the 'func' 2 times by creating the 2 threads and passed the arguments in the function 'func1'. here I passed 2 arguments time, name of the thread.


GIL:
----
-->The global intepreter lock is the single lock, that is the python interpreter is using to protect crucial shared data structures from getting corrupted when many threads are used. The GIL allows only one thread to execute python instructions at a time. this is the limitation. This causes the threads to be underutilized. There is another thing that makes the threads underutilized is 'waiting for external resources also known as input/output or I/O for short'. This is where the idea of 'asyncio' is came. the goal of the ayncio is "maximize the usage of a single thread by handling I/O asynchronously and enabling concurrent code using coroutines". The asyncio enables single threaded programs to be more productive by filling the gaps that would, otherwise be wasted on waiting on IO. To do efficiantly the asyncio avoids using the blocking functions. During the I/O heavy workload asynchronous IO can work faster than the blocking IO.  



---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


                                            17-01-2022
                                            ----------

tasks:
------
sample input for custom testing.

stdin    function
-----    ---------
4  ---> songs[] size n = 4
10 ---> songs = [10, 50, 90, 30]

-->the first and second songs pair to 60 seconds. the third and fourth songs pair to 120 seconds. no other pairs will satisfy the requirement. 

solution:
---------
list1 = [10, 50, 90, 30]

length = len(list1)

result = []

for i in range(length):
    for j in list1[i + 1 : ]:
        print(list1[i], j)
        if list1[i] != j and (list1[i] + j) % 60 == 0:
            result.append([list1[i], j])

print(len(result))
print(result)

output:
-------
2
[[10, 50], [90, 30]]



task:
-----
stdin  function
-----  ---------
5  ---> total = 5
3  ---> k = 3

sample output:
--------------
5

explanation:
-------------
-->the sum required is 5. k = 3 so that integers that can be considered to reach the sum are [1,2,3].

the 5 ways to reach the target sum are :

1) 1 + 1 + 1 + 1 + 1 = 5
2) 1 + 1 + 1 + 2 = 5
3) 1 + 2 + 2 = 5
4) 1 + 1 + + 3 = 5
5) 2 + 3 = 5


solution :
----------
n = int(input('enter the number : '))

k = int(input('enter the k value : '))

result = []

for i in range(1, n +1):
    
    if i == 1 and i * n == n:
        result.append(i)

    elif i < n and (1 * (n - i)) + i == n:
          result.append(i)

print(result[:k])

output:
-------
enter the number : 5
enter the k value : 2
[1, 2]


regular expressions:
--------------------
-->regular expressions, also known as regexes, in Python. A regex is a special sequence of characters that defines a pattern for complex string-matching functionality.

-->let's say we have a string, if we want to find out whether the sbustring is in the main string. we use the comparison operator 'in'. 

example:
--------
string = 'hello world'
print('hello' in string)

output:
-------
True
>>> 

-->if you want to know not only whether '123' exists in string but also where it exists, then you can use find() or index(). 

example:
--------
string = 'hello world'
print(string.find('hello'))
print(string.index('world'))

output:
-------
0
6
>>> 


-->In these examples, the matching is done by a straightforward character-by-character comparison. That will get the job done in many cases. But sometimes, the problem is more complicated than that.

For example, rather than searching for a fixed substring like '123', suppose you wanted to determine whether a string contains any three consecutive decimal digit characters, as in the strings 'foo123bar', 'foo456bar', '234baz', and 'qux678'.

Strict character comparisons wont cut it here. This is where regexes in Python come to the rescue.

re package:
-----------
-->Regex functionality in Python resides in a module named re. The re module contains many useful functions and methods. let's go through the function re.search(). the syntax is 

re.search(<regex>, <string>)

-->what this function do is it scans a string for a regex match. re.search(<regex>, <string>) scans <string> looking for the first location where the pattern <regex> matches. If a match is found, then re.search() returns a match object. Otherwise, it returns None.

example:
--------
import re
s = 'foo123bar'
print(re.search('123', s))

output:
-------
<re.Match object; span=(3, 6), match='123'>


-->The interpreter displays the match object as <_sre.SRE_Match object; span=(3, 6), match='123'>. This contains some useful information.

span=(3, 6) indicates the portion of <string> in which the match was found. 

-->Here, the search pattern <regex> is 123 and <string> is s. For the moment, the important point is that re.search() did in fact return a match object rather than None. That tells you that it found a match. In other words, the specified <regex> pattern 123 is present in s.


-->A match object is truthy, so you can use it in a Boolean context like a conditional statement:

example:
--------
import re
s = 'foo123bar'

if re.search('123', s):
    print('found a match')

else:
    print('no match')

output:
-------
found a match


regex metacharacters:
----------------------
-->The real power of regex matching in Python emerges when <regex> contains special characters called metacharacters. These have a unique meaning to the regex matching engine and vastly enhance the capability of the search.

-->Consider again the problem of how to determine whether a string contains any three consecutive decimal digit characters.

-->In a regex, a set of characters specified in square brackets ([]) makes up a character class. This metacharacter sequence matches any single character that is in the class

example:
--------
<re.Match object; span=(3, 6), match='123'>


-->[0-9] matches any single decimal digit characterany character between '0' and '9', inclusive. The full expression [0-9][0-9][0-9] matches any sequence of three decimal digit characters. In this case, s matches because it contains three consecutive decimal digit characters, '123'.

example:
--------
import re
s = 'foo123bar'
print(re.search('[0-9][0-9][0-9]', s))

print(re.search('[0-9][0-9][0-9]', '234baz'))

print(re.search('[0-9][0-9][0-9]', 'qux678'))

output:
-------
<re.Match object; span=(3, 6), match='123'>
<re.Match object; span=(0, 3), match='234'>
<re.Match object; span=(3, 6), match='678'>


-->if no match is found the search() function returns None. see below : 

example:
--------
import re
print(re.search('[0-9][0-9][0-9]', '12foo34'))

output:
-------
None

-->With regexes in Python, you can identify patterns in a string that you wouldnt be able to find with the in operator or with string methods.


-->Take a look at another regex metacharacter. The dot (.) metacharacter matches any character except a newline, so it functions like a wildcard:

example:
--------
import re
s = 'foo123bar'

print(re.search('1.3', s))

s = 'foo1 3bar'

print(re.search('1.3', s))

s = 'foo1#3bar'

print(re.search('1.3', s))

s = 'foo13bar'

print(re.search('1.3', s))


output:
-------
<re.Match object; span=(3, 6), match='123'>
<re.Match object; span=(3, 6), match='1 3'>
<re.Match object; span=(3, 6), match='1#3'>
None


-->In the first example, the regex 1.3 matches '123' because the '1' and '3' match literally, and the . matches the '2'. here for the characters like space, special characters also it is working.


Metacharacters Supported by the re Module : 
------------------------------------------
-->The following table briefly summarizes all the metacharacters supported by the re module. Some characters serve more than one purpose:

Character(s)    Meaning
------------    -------
.               Matches any single character except newline

^                Anchors a match at the start of a string
                 Complements a character class

$               Anchors a match at the end of a string

*               Matches zero or more repetitions

+               Matches one or more repetitions

?                Matches zero or one repetition
                 Specifies the non-greedy versions of *, +, and ?
                 Introduces a lookahead or lookbehind assertion
                 Creates a named group

{}              Matches an explicitly specified number of repetitions

\                Escapes a metacharacter of its special meaning
                 Introduces a special character class
                 Introduces a grouping backreference

[]              Specifies a character class

|               Designates alternation

()              Creates a group

:
#
=
!               Designate a specialized group

<>              Creates a named group



Metacharacters That Match a Single Character:
---------------------------------------------
-->this is about [], this try to match a single character from the search string. 

-->Characters contained in square brackets ([]) represent a character classan enumerated set of characters to match from. A character class metacharacter sequence will match any single character contained in the class.

example:
--------
import re

print(re.search('ba[artz]', 'foobarqux'))

print(re.search('ba[artz]', 'foobazqux'))
      
output:
-------
<re.Match object; span=(3, 6), match='bar'>
<re.Match object; span=(3, 6), match='baz'>


-->The metacharacter sequence [artz] matches any single 'a', 'r', 't', or 'z' character. In the example, the regex ba[artz] matches both 'bar' and 'baz' (and would also match 'baa' and 'bat').


-->A character class can also contain a range of characters separated by a hyphen (-), in which case it matches any single character within the range. For example, [a-z] matches any lowercase alphabetic character between 'a' and 'z', inclusive:

example:
--------
import re

print(re.search('[a-z]', 'FOObar'))

output:
-------
<re.Match object; span=(3, 4), match='b'>

-->[0-9] matches any digit characters

example:
--------
import re

print(re.search('[0-9][0-9]', 'foo123bar'))

output:
-------
<re.Match object; span=(3, 5), match='12'>

-->In this case, [0-9][0-9] matches a sequence of two digits. The first portion of the string 'foo123bar' that matches is '12'.


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


                                            18-01-2022
                                            ----------


-->You can complement a character class by specifying ^ as the first character, in which case it matches any character that isnt in the set. In the following example, [^0-9] matches any character that isnt a digit: 

example:
--------
import re

print(re.search('[^0-9]', '12345foo'))

print(re.search('[^0-9]', '12345'))

output:
-------
<re.Match object; span=(5, 6), match='f'>
None

-->here hte match object indicates that the first character in the string that is not digit is 'f'. 


-->If a ^ character appears in a character class but isnt the first character, then it has no special meaning and matches a literal '^' character:

example:
--------
import re

print(re.search('[#:^]', 'foo^bar:baz#'))

output:
-------
<re.Match object; span=(3, 4), match='^'>


-->usually you can specify a range of characters in a character class by separating characters with a hyphen. what if you want the character class to include a literal hyphen character?. you can place it as the first or last character or escape it with a backslash(\). see below : 

example:
--------
import re

print(re.search('[-abc]', '123-456'))

print(re.search('[abc-]', '123-456'))

print(re.search('[ab\-c]', '123-456'))

output:
-------
<re.Match object; span=(3, 4), match='-'>
<re.Match object; span=(3, 4), match='-'>
<re.Match object; span=(3, 4), match='-'>


-->If you want to include a literal ']' in a character class, then you can place it as the first character or escape it with backslash:

example:
--------
import re

print(re.search('[]]', 'foo[1]'))

print(re.search('[ab\]cd]', 'foo[1]'))

output:
-------
<re.Match object; span=(5, 6), match=']'>
<re.Match object; span=(5, 6), match=']'>


-->Other regex metacharacters lose their special meaning inside a character class:

example:
--------
import re

print(re.search('[)*+|]', '123*456'))

print(re.search('[)*+|]', '123+456'))

output:
-------
<re.Match object; span=(3, 4), match='*'>
<re.Match object; span=(3, 4), match='+'>

-->As you saw in the table above, * and + have special meanings in a regex in Python. They designate repetition, which youll learn more about shortly. But in this example, theyre inside a character class, so they match themselves literally.


dot(.):
-------
-->used to specifies a wildcard. the '.' metacharacter matches any single character except a new line. 

example:
--------
import re

print(re.search('foo.bar', 'fooxbar'))

print(re.search('foo.bar', 'foobar'))

print(re.search('foo.bar', 'foo\nbar'))

output:
-------
<re.Match object; span=(0, 7), match='fooxbar'>
None
None

-->As a regex, foo.bar essentially means the characters 'foo', then any character except newline, then the characters 'bar'. The first string shown above, 'fooxbar', fits string because the . metacharacter matches the 'x'.

The second and third strings fail to match. In the last case, although theres a character between 'foo' and 'bar', its a newline, and by default, the . metacharacter doesnt match a newline.

\w and \W :
-----------
-->this is used to match based on whether a character is word character. 

-->\w matches any alphanumeric word character. Word characters are uppercase and lowercase letters, digits, and the underscore (_) character, so \w is essentially shorthand for [a-zA-Z0-9_]:

example:
--------
import re

print(re.search('\w', '#(.a$@&'))

print(re.search('[a-zA-Z0-9_]', '#(.a$@&'))

output:
-------
<re.Match object; span=(3, 4), match='a'>
<re.Match object; span=(3, 4), match='a'>

-->In this case, the first word character in the string '#(.a$@&' is 'a'.


\d and \D:
----------
-->this is used to match based on whether a character is a decimal digit. \d matches any decimal digit character. \D is the opposite. it matches any character that is not decimal digit. 

example:
--------
import re

print(re.search('\d', 'abc4def'))

print(re.search('\D', '234Q678'))

output:
-------
<re.Match object; span=(3, 4), match='4'>
<re.Match object; span=(3, 4), match='Q'>

-->\d is essentially equivalent to [0-9], and \D is equivalent to [^0-9].


\s and \S:
----------
-->this is used to match based on whether a character represents whitespace. \s matches any whitespace character. 

example:
--------
import re

print(re.search('\s', 'foo\nbar baz'))

output:
-------
<re.Match object; span=(3, 4), match='\n'>

-->unlike the dot wildcard metacharacter, \s does match a newline character. 

-->\S is the opposite of \s. It matches any character that is not whitespace. 

example:
--------
import re

print(re.search('\S', ' \n foo \n '))

output:
-------
<re.Match object; span=(3, 4), match='f'>

-->again, \s, \S consider a newline to be whitespace. here the first non-whitespace character is 'f'. 

-->The character class sequences \w, \W, \d, \D, \s, and \S can appear inside a square bracket character class as well.

example:
--------
import re

print(re.search('[\d\w\s]', '---3---'))

print(re.search('[\d\w\s]', '---a---'))

print(re.search('[\d\w\s]', '--- ---'))


output:
-------
<re.Match object; span=(3, 4), match='3'>
<re.Match object; span=(3, 4), match='a'>
<re.Match object; span=(3, 4), match=' '>

-->In this case, [\d\w\s] matches any digit, word, or whitespace character. And since \w includes \d, the same character class could also be expressed slightly shorter as [\w\s].

Escaping metacharacters:
------------------------
-->sometimes we want to mention a metacharacter in our regualar expression and we dont' want it carry its special meaning. at that time we want to represent itself as a literal character.

backslash(\):
-------------
-->this is used to removes the special meaning of a metacharacter.  A metacharacter preceded by a backslash loses its special meaning and matches the literal character instead.

example:
--------
import re

print(re.search('.', 'foo.bar'))

print(re.search('\.', 'foo.bar'))

output:
-------
<re.Match object; span=(0, 1), match='f'>
<re.Match object; span=(3, 4), match='.'>


-->here in teh first line the dot functions as a wildcard metacharacter, which matches the first character in teh string 'f'. the '.' character in the second print statement, it is escaped by a backslash, so it is not a wildcard. it is interpreted literally and matches the '.' at the 3 position of the string. 

-->Using backslashes for escaping can get messy. Suppose you have a string that contains a single backslash. let's say string = r'foo\bar'. now you want to create a regex that will match teh backslash between 'foo' and 'bar'. the backslash is itself is a special character in a regex. so to specify a literal backslash, we need to escape it with antoher backslash. 

example:
--------
import re

s = r'foo\bar'

print(re.search('\\', s))

output:
-------
Traceback (most recent call last):
  File "C:\Users\this\Desktop\sample1.py", line 5, in <module>
    print(re.search('\\', s))
  File "C:\Users\this\AppData\Local\Programs\Python\Python38\lib\re.py", line 201, in search
    return _compile(pattern, flags).search(string)
  File "C:\Users\this\AppData\Local\Programs\Python\Python38\lib\re.py", line 304, in _compile
    p = sre_compile.compile(pattern, flags)
  File "C:\Users\this\AppData\Local\Programs\Python\Python38\lib\sre_compile.py", line 764, in compile
    p = sre_parse.parse(p, flags)
  File "C:\Users\this\AppData\Local\Programs\Python\Python38\lib\sre_parse.py", line 940, in parse
    source = Tokenizer(str)
  File "C:\Users\this\AppData\Local\Programs\Python\Python38\lib\sre_parse.py", line 232, in __init__
    self.__next()
  File "C:\Users\this\AppData\Local\Programs\Python\Python38\lib\sre_parse.py", line 245, in __next
    raise error("bad escape (end of pattern)",
re.error: bad escape (end of pattern) at position 0


-->this returned the error, because interpreter is taking this expression in the wrong way. to avoid this error, use 2 escape sequences again. 

example:
--------
import re

s = r'foo\bar'

print(re.search('\\\\', s))

output:
-------
<re.Match object; span=(3, 4), match='\\'>



-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


                                              19-01-2022
                                              ----------

task:
-----
Array operations : efficient meeting:
-------------------------------------
there are N people in an organization. they are located on different point of the nubmer line. they have decided to meet a  common point. Find the minimum distance they have to cover in totoal to meet at a common point. 

input format:
-------------
The input consist of single number N, denoting the numbers of people in the organization. the second line  consist of an array X of N integers, denoting the positions of the people on the line.

constraints:
------------
1 <= N <= 100

output format:
--------------
-->the output contains the single integer which is denoting the minimum total distance they have to travel to meet at the common point. 

explanation:
------------
-->let's take the meeting point as 10.

solutions:
----------
def min_distance(N, X):

    result = 0
    point = 10

    for i in X:
        if i < point:
            result = result + (point - i)

        elif i > point:
            result = result + (i - point)

    return result

N = int(input('enter the number of points : '))

X = []

for i in range(N):
    value = int(input('enter the value : '))
    X.append(value)

print(min_distance(N, X))
    
output:
-------
enter the number of points : 4
enter the value : 20
enter the value : 50
enter the value : 40
enter the value : 60
130



task:
-----
You and Fredrick are good friends. Yesterday, Fredrick received  credit cards from ABCD Bank. He wants to verify whether his credit card numbers are valid or not. You happen to be great at regex so he is asking for your help!

A valid credit card from ABCD Bank has the following characteristics:

 It must start with a 4,5 or 6 .
 It must contain exactly  digits.
 It must only consist of digits (-).
 It may have digits in groups of , separated by one hyphen "-".
 It must NOT use any other separator like ' ' , '_', etc.
 It must NOT have  or more consecutive repeated digits.

solution :(not finished)
----------
number = '5122-2368-7954-3214'


def starts():
    if number.startswith(('4', '5', '6')):
        return True


def delimiter():
    for i in number:
        if not i.isdigit() and i == '-':
            return i
        else:
            return False

def length():
    num_list = number.split(delimiter())
    if len(num_list) == 16:
        return True

            
def repeat(i):
    temp = []
    for number in i:
        if number.count(i) > 3:
            return False
        else:
            return True          
            
            
print(starts())
print(delimiter())
repeat()


data classes:
-------------
--> A data class is a class typically containing mainly data, although there arent really any restrictions. It is created using the new @dataclass decorator. the sample one looks like this : 

example:
--------
from dataclasses import dataclass

@dataclass
class Sample:
    name: str
    number: int


-->let's write a sample program using the data classes. see below : 

example:
--------
from dataclasses import dataclass

@dataclass
class Sample:
    name : str
    number : int

obj = Sample('john', 123)

print(obj.name)
print(obj)

output:
-------
john
Sample(name='john', number=123)


-->here I created a simple classes using the data classes. here I used the syntax name : str, which means we are using the type annotations. here if we write the type hints in wrong way like, name : int, number : str, this won't give the error. the reason is mentioning the type hint is for user readability. see below :


example:
--------
from dataclasses import dataclass

@dataclass
class Sample:
    name : int
    number : str

obj = Sample('john', 123)

print(obj.name)
print(obj)

output:
-------
john
Sample(name='john', number=123)

-->see here it don't give any error. 'john' goes to the name field and '123' goes to the number field. 

-->using the dataclasses we can also compare the 2 dataclass instances. see below : 

example:
-------
from dataclasses import dataclass

@dataclass
class Sample:

    name : str
    number : int

obj = Sample('john', 123)

print(obj.name)

print(obj)

print(obj == Sample('john', 123))

output:
-------
john
Sample(name='john', number=123)
True

-->here obj == sample('john', 123) means, we are comparing the 2 instances. here both the objects has the same data, that is why it is returning true. if both the objects has the different data, then it will return the false. see below : 

example:
--------
from dataclasses import dataclass

@dataclass
class Sample:

    name : str
    number : int

obj = Sample('john', 123)

print(obj.name)

print(obj)

print(obj == Sample('mike', 123))

output:
-------
john
Sample(name='john', number=123)
False


-->let's just compare this with our regular classes, where we use the __init__() constructor. see below : 

example;
--------
class Sample:

    def __init__(self, name, number):
        self.name = name
        self.number = number

obj = Sample('mike', 123)

print(obj.name)

print(obj)

print(obj == Sample("mike", 123))

otuput:
-------
mike
<__main__.Sample object at 0x0000000002D02EB0>
False

-->when compare this to the data classes, we have to write lot of things. Furthermore, if you try to use this plain class, youll notice that the representation of the objects is not very descriptive. while using the dataclasses if we pritn the objects it prints the view object,but  when we are writing the plain classes, when print the object, it prints the address.

-->another thing is we can compare 2 instances, but even their data is same, it will return false. 

-->data classes are helping us out behind the scenes. By default, data classes implement a .__repr__() method to provide a nice string representation and an .__eq__() method that can do basic object comparisons. For the Sample class to imitate the data class above, you need to add these methods as well: 

example:
--------
class Sample:

    def __init__(self, name, number):
        self.name = name
        self.number = number

    def __repr__(self):
        return (f'{self.__class__.__name__}'
                f'(name = {self.name!r}, number = {self.number!r})''

    def __eq__(self, other):
        if other.__class__ is not self.__class__:
            return NotImplemented
        return (self.name, self.number) == (other.name, other.number)


obj = Sample('mike', 123)

print(obj.name)

print(obj)

print(obj == Sample('mike', 123))

output:
-------
mike
Sample(name = 'mike', number = 123)
True


-->in dataclasses we can use the default values also. see below : 

example:
--------
from dataclasses import dataclass

@dataclass
class Sample:

    name : str
    number : int = 123
    age : int = 20

obj = Sample('mike')

print(obj.number)

output:
-------
123

-->This works exactly as if you had specified the default values in the definition of the .__init__() method of a regular class. here we can create the object in 4 different ways. see below : 

example:
--------
from dataclasses import dataclass

@dataclass
class Sample:

    name : str
    number : int = 123
    age : int = 20

obj1 = Sample('mike')
print(obj1)

obj2 = Sample('mike', number = 123)
print(obj2)

obj3 = Sample('mike', age = 20)
print(obj3)

obj4 = Sample('mike', number = 123, age = 20)
print(obj4)

output:
-------
Sample(name='mike', number=123, age=20)
Sample(name='mike', number=123, age=20)
Sample(name='mike', number=123, age=20)
Sample(name='mike', number=123, age=20)
