
								
								slicing works different with mutable and immutable
								--------------------------------------------------

example: THIS IS VERY IMPORTANT
--------
-->The [:] syntax works for lists. However, there is an important difference between how this operation works with a list and how it works with a string.

If s is a string, s[:] returns a reference to the same object:

>>> s = 'foobar'
>>> s[:]
'foobar'
>>> s[:] is s
True

-->the main thing is the slicing works different way when comes to the mutable and the immutable data types. but when comes to the list it is different. see below : 
exmaple :
--------
a = [1,2,3]
print(a is a[:])

output:
-------
False

-->here the a and a[:], they both pointing to the different address. but when come to the string it is different. not only string, if you take any other immutable object, it works different way. let's take a look at the tuple : 
example:
--------
a = (1,2,3)
print(a is a[:])

output:
-------
True

-->here the 'a' and 'a[:]', they pointing the same address.

---------------------------------------------------------------------------------------------------------------

-->find a given number is armstrong number or not 

solution :
----------
def armstrong(number):
    total = 0
    for i in number:
        total = total + int(i) ** 3

    if int(number) == total:
        print(f'the number {number} is the armstrong number')
    else:
        print(f'the number {number} is not armstrong')

number = input('enter the number : ')

armstrong(number)


--------------------------------------------------------------------------------------------------------------

Task
Given an integer, , perform the following conditional actions:

If  is odd, print Weird
If  is even and in the inclusive range of 2 to 5, print Not Weird
If  is even and in the inclusive range of 6 to 20, print Weird
If  is even and greater than 20, print Not Weird

solution :
----------
def func(n):
    if n % 2 != 0:
        return 'wierd'
    elif n % 2 == 0:
        if n in range(2, 6):
            return 'not weird'
        elif n in range(6, 21):
            return 'weird'
        elif n > 20:
            return 'not weird'

print(func(int(input('enter the number : '))))

output:
-------
enter the number : 5
wierd


--------------------------------------------------------------------------------------------------------------

Minion game:
------------

Game Rules

Both players are given the same string, .
Both players have to make substrings using the letters of the string .
Stuart has to make words starting with consonants.
Kevin has to make words starting with vowels.
The game ends when both players have made all possible substrings.

Scoring
A player gets +1 point for each occurrence of the substring in the string .

For Example:
String  = BANANA
Kevin's vowel beginning word = ANA
Here, ANA occurs twice in BANANA. Hence, Kevin will get 2 Points.

solution:
---------
def minion(string):
    vowels = ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
    stuart_score = 0
    kevin_score = 0
    kevin_words = []
    stuart_words = []

    for i in range(len(string)):
        if string[i] not in vowels:
        	#this count the combinations based on the count like for 'hell' it takes h, he, hel, hell
            stuart_score += len(string[i : ])
            
        elif string[i] in vowels:
            kevin_score += len(string[i : ])
            
    print('stuart score is :',  stuart_score)
    print('kevin score is : ', kevin_score)

    if stuart_score > kevin_score:
        print('stuart wins')

    elif stuart_score < kevin_score:
        print('kevin wins')
        
    else:
        print('both wins')


minion(input('enter the string : '))

-->the above code can give you the number of combinations, but it don't print all the word combinations. below code prints all the details : 

solution : 
----------
def minion(string):
    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']
    stuart_score = 0
    kevin_score = 0
    kevin_words = []
    stuart_words = []

    for i in range(len(string)):
        if string[i] not in vowels:
            temp = string[i : ]
            #this count the combinations based on the count like for 'hell' it takes h, he, hel, hell
            stuart_score += len(string[i : ])
            for i in range(len(temp)):
                stuart_words.append(temp[0 : i + 1])
            
            
        elif string[i] in vowels:
            temp = string[i : ]
            #this count the combinations based on the count like for 'hell' it takes h, he, hel, hell
            kevin_score += len(string[i : ])
            for i in range(len(temp)):
                kevin_words.append(temp[0 : i + 1])
            
    print('stuart score is :',  stuart_score)
    print('\nstuart combination words :',  stuart_words)
    print('\nkevin score is : ', kevin_score)
    print('\nkevin combination words :', kevin_words)

    if stuart_score > kevin_score:
        print('\nstuart wins')

    elif stuart_score < kevin_score:
        print('\nkevin wins')
        
    else:
        print('\nboth wins')


minion(input('enter the string : '))

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



												29-12-2021
												----------


functions:
----------
-->the type of the function variable, it is always belogns to the class 'function', see below :

example:
--------
def func():
    pass

print(type(func))

output:
-------
<class 'function'>


-->if you check the return type of the function, then it will return "NoneType" if it is not returning anything, if it is return anything, then it return the data type of the returning values. see below : 

example:
--------
def func():
    pass

print(type(func()))

output:
-------
<class 'NoneType'>


-->for example if the function is returning the string, then the return type of the function is string. see below : 

example:
--------
def func():
    return 'hello world'

print(type(func()))

output:
-------
<class 'str'>


functions vs methods:
----------------------
-->if we write the function inside the class, then the type of that function is not 'class function'. see below :

example:
--------
class Hello:

    def func(self):
        pass

obj = Hello()
print(type(obj.func))

output:
--------
<class 'method'>

-->here, when we write the function inside the class, the type of that function variable is changed to 'class method'. if we don't write the function inside the class, then that' function variable's return type is 'class function'. this one of the way to identify the difference between the functions and methods. 


inner functions:
----------------
-->these are just function within another function, we can call them as the nested functions.

example:
--------
def outer():
    print('this is the outer function')
    def inner():
        print('this is the inner function')
    return inner()

outer()

output:
-------
this is the outer function
this is the inner function


encapsulation with inner functions:
-----------------------------------
-->A common use case of inner functions arises when you need to protect, or hide, a given function from everything happening outside of it so that the function is totally hidden from the global scope. This kind of behavior is commonly known as encapsulation.

example:
--------
def add(number):
    def inner():
        return number + 1
    return inner()

inner()

output:
-------
Traceback (most recent call last):
  File "C:\Users\this\Desktop\sample1.py", line 6, in <module>
    inner()
NameError: name 'inner' is not defined

-->here we can't access the inner function directly, because the outer function is hiding the inner function from accessing directly.


-->the inner function has access to the outer functions state.

example:
--------
def square(number):
    def inner(power):
        return number ** power
    return inner(2)

print(square(10))
    
output:
-------
100

-->here the inner function has the access to the outer function data 'number'. 

example : writing multiple nested functions
---------
def square(number):
    def outer(power):
        def inner():
            return number ** power
        return inner()
    return outer(2)

print(square(10))
    
output:
-------
100

-->here the 'inner' function has the access to the parameters of the outer functions outer and square.



recursion functions:
--------------------
-->a function which calls itself again and again. 

example: calculate the sum of first 10 numbers
--------
def func(number):
    if number == 1:
        return 1
    else:
        return number + func(number - 1)

print(func(20))

output:
-------
55


-->there is another way we can write the above program

example:
--------
def func(number):
    return number + func(number - 1) if number > 0 else 0 

print(func(5))

output:
--------
15


example: calculate the factorial of a number using recursion 
--------
def func(number):
    if number == 1:
        return 1
    else:
        return number * func(number - 1)

print(func(6))

output :
--------
720


functions are the fist class object:
------------------------------------
-->the functions in python are called as the first class objects, there are 4 main reasons : 
1)we can return a function from another function
2)we can pass the function as the argument to anothe function
2)we can store the return value of the function in a variable
4)we can create one function within another function

pass function as the argument:
------------------------------
example:
--------
def add():
    return 10 + 20

def result(add):
    value = add()
    return value

print(result(add))

output:
-------
30

-->here I passed the function 'add' as the argument to the function 'result'. we can also pass the anonymous functions 'lambda' as the argument to another function. see below :

example:
--------
def result(add):
    value = add()
    return value

print(result(lambda : 10 + 20))

output:
--------
30

-->we can also write the above program by simplye storing the lambda function in a variable and pass that variable. see below : 

example:
--------
def result(add):
    value = add()
    return value

value = lambda : 10 + 20
print(result(value))

output:
-------
30


-->let's prints numbers from 1 to 10, by passing the function as the argument in the list comprehension
example:
--------
def func():
    return 10

print([i for i in range(func())])

output:
-------
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]




Task:
-----
-->in the below list, find the names with maximum marks and sorted the names

solution:
---------
data = [['b', 10], ['c', 20], ['a', 20]]

names = []
marks = []

for i, j in data:
    names.append(i)
    marks.append(j)

max_marks = max(marks)

list1 = []

for i, j in data:
    if j == max_marks:
        list1.append(i)

print(sorted(list1))

output:
-------
['a', 'c']


Task:
-----
-->sort dictionary based on values:

solution:
---------
data = [['b', 10], ['a', 20], ['c', 20]]

names = []
marks = []
dict1 = {}

for i, j in data:
    dict1[i] = j

for i, j in dict1.items():
    value = max(dict1.values())
    if j == value:
        print(i)

output:
-------
a
c


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

												Decorators(3-1-2022)
												--------------------

-->the decorators pattern is an object oriented design pattern that allows behaviour to be added to an existing object dynamically. when you decorate an object then you extend it's functionality in a way that is independet of other instances of the same class.

-->python decorators add functionality to functions and methods at the definitions time, they are not used to add the functinality at run time.

-->we have 2 types of decorators in python. decorators can be applied to both functions and classes.
1)function decorator
2)class decorator


function decorator:
-------------------
-->to implement the function decorator, we need 2 functions. one function is to take the decorator function as the argument and an inner function to call the decorator function. first let's see how the inner functions works. 

example:
--------
def outer():
    print('this is the outer function')
    def inner():
        print('this is the inner function')
    return inner

print(outer())

output:
-------
this is the outer function
<function outer.<locals>.inner at 0x0000000002D74670>

-->here it returned the function object, the reason is the return value of the outer() is 'inner' which is the function variable. if you print the function variable, it will give you the address. here the inner() is not called, you can call it in the return statement. see below : 

example:
--------
def outer():
    print('this is the outer function')
    def inner():
        print('this is the inner function')
    return inner()

print(outer())

output:
-------
this is the outer function
this is the inner function
None

-->here it returns the 'None', the reason is the inner function is not returning anything. if the functions is not returnig anything it's return value is None. 

-->let's taka look at the sample decorator : 

example:
--------
def decorator(func):
    print('this is the decorator function')
    def inner():
    	
        print('this is the inner function')
        func()
        
    return inner

@decorator
def main():
    print("this is the main function ")

main()

output:
-------
this is the decorator function
this is the inner function
this is the main function 

-->here the we have the decorator function 'decorator'. main() is the decorated function. the 'decorator' function takes the 'main' as the argument. her func = main. the reason why we have the 'inner' function is, it called the 'main' function.

-->actually this is the new style of implementing the function decorators. before '@' was introduced, there is another way to invoke the decorators. see below : 

example:
--------
def decorator(func):
    print('this is the decorator function')
    def inner():    	
        print('this is the inner function')
        func()
        
    return inner


def main():
    print("this is the main function ")

main = decorator(main)

main()

output:
-------
this is the decorator function
this is the inner function
this is the main function 

-->here instread of using the '@' symbol, we invoked the decorator in the old style. here 'decorator(main)' calls the decorator function with 'main' as the argument. the return value of the 'decorator(func) is 'inner'. now the main is point to the 'inner'. so when you call the main(), it calls the inner() functions.

-->we can decorator many functions using the single decorator. see below : 

exmaple:
--------
def decorator(func):
    def inner():
        print('this is the function : ', func.__name__)
    return inner

@decorator
def func1():
    print('this is func1')

@decorator
def func2():
    pass

func1()
func2()

output:
-------
this is the function :  func1
this is the function :  func2

-->here we decorated the 2 functions func1 and func2. when you call func1(), func(2), they calls the inner function 2 times. 

-->let's write the above progrma without using the '@decorator'. see below : 

example:
---------
def decorator(func):
    def inner():
        print('this is the function : ', func.__name__)
    return inner


def func1():
    print('this is func1')

func1 = decorator(func1)
func1()


def func2():
    pass

func2 = decorator(func2)
func2()

output:
-------
this is the function :  func1
this is the function :  func2


-->we can write the nested decorators also. see below :
example:
--------
def first_dec(func):
    def inner():
        print('this is the first decorator')
        return func()
    return inner

def second_dec(func):
    def inner():
        print('this is the second decorator')
        return func()
    return inner

@first_dec
@second_dec
def main():
    print('this is the main function')

main()

output:
-------
this is the first decorator
this is the second decorator
this is the main function

-->here the inner decorator executes first, then the outer decorator executes, then finally the main() function is called. let's write this code without using '@decorator'.

example:
--------
def first_dec(func):
    def inner():
        print('this is the first decorator')
        return func()
    return inner

def second_dec(func):
    def inner():
        print('this is the second decorator')
        return func()
    return inner

def main():
    print('this is the main function')

main = first_dec(second_dec(main))

main()

output:
-------
this is the first decorator
this is the second decorator
this is the main function


@wraps:
-------
-->there is one flaw in code written above. see below : 

example:
--------
def decorator(func):
    def inner():
        print('this is the inner function : ', func.__name__)
        func()
    return inner

@decorator
def main():
    print('this is the main function')

main()
main()

output:
-------
this is the inner function :  main
this is the main function
this is the inner function :  main
this is the main function

-->here every time we call the main() function, it is not calling the main() function, it is called the inner() function. the reason is the main function variable 'main' is pointing to the inner() function variable 'inner'. but this is not how it should be. the function variable 'main' should always pointing to it's function main(). so avoid that we have to use the other decorator '@wraps' from the 'functools' module. see below : 

example:
--------
from functools import wraps
def decorator(func):
    @wraps(func)
    def inner():
        print('this is inner function : ', func.__name__)
        func()
    return inner

@decorator
def main():
    print('this is the main function')

main()

-->For the decorator '@wraps(func)', we have to pass the function variable for which we want to do dereferencing. here the 'func' contains 'main', so @wraps(func) make the referencing, so that after the execution of the above code main is no longer points to the 'inner' function. 
'

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


										       04-01-2022
											----------

class decorators:
-----------------
-->a decorator can not only be a function, it can also be a class. when compared to the execution flow, the class decorators are bit different from the function decorators. see below :

example:
--------
class entry_exit():

    def __init__(self, f):
        self.f = f

    def __call__(self):
        print('entering into the ', self.f.__name__)
        self.f()
        print('exiting the function', self.f.__name__)

@entry_exit
def func1():
    print('inside func1')

@entry_exit
def func2():
    print('inside func2')

func1()
func2()

-->here when the control hits the '@entry_exit', it calls the '__init__()' constructor, with function variable 'func1' as the argument. so in the __ini__(self, f), f contains the 'func1'. the samething applicable for the function 'func2'. when func1() and func2() is called, internally '__call__()' method will be called, here we override the dunder __call__() method. this method will call the main functions 'func1' and 'func2'. 

-->while working with the functiond decorators, we invoked the decorator without using the '@' syntax. for the class decorators also we can invoke them without using the '@'. see below : 

example:
--------
class Entry_exit():

    def __init__(self, f):
        self.f = f

    def __call__(self):
        print('before the function : ', self.f.__name__)
        self.f()
        print('after the function : ', self.f.__name__)

def func1():
    print('this is the func1')

func1 = Entry_exit(func1)

def func2():
    print('this is the func2')

func2 = Entry_exit(func2)

func1()
func2()

output:
-------
before the function :  func1
this is the func1
after the function :  func1
before the function :  func2
this is the func2
after the function :  func2


-->the reason why the class decorator class the __init__() method is, the syntax 'func2 = Entry_exit(func2)', here the 'Entry_exit(func2)', is like the object instantiation syntax. so when instantiation happens, it calls the __init__() constructor immediately.

-->here the syntax 'func1 = Entry_exit(func1)', you may get the doubt that, func1 could be the object. actually here func1 represents the object as well as the function variable. so here 'self' represents the object as well as the function variable. so you can call like 'self()'. it dont' give error, but it goes into the infinite loop. because every time you call self(), it calls the __call__() method, again self() is called, again __call__() is executed. so avoid this practice. see below code : 

example:
--------
class Entry_exit():

    def __init__(self, f):
        self.f = f

    def __call__(self):
        print('before the function : ', self.f.__name__)
        self()
        print('after the function : ', self.f.__name__)

def func1():
    print('this is the func1')

func1 = Entry_exit(func1)

def func2():
    print('this is the func2')

func2 = Entry_exit(func2)

func1()
func2()

-->this code goes into infinite loop.


decorators with arguments:
--------------------------
-->we can pass the arguments to the function decorators. for writing the decorators with arguments, you need to have 2 inner functions. see below : 

example:
--------
import random
def power_of(exponent):
    def decorator(func):
        def inner():
            return func() ** exponent
        return inner
    return decorator

power = int(input('enter the exponent : '))

@power_of(power)
def random_odd_digit():
    return random.choice([3,5,7])

print(random_odd_digit())

output:
-------
enter the exponent : 2
9

-->here the reason why we have 3 functions in the decorator is, the outer function will take the argument, next the decorator function takes the function as the argument and the inner function is used to call the main function or decorated function. let's write the above code without using the '@' syntax : 

example:
---------
import random
def power_of(exponent):
    def decorator(func):
        def inner():
            return func() ** exponent 
        return inner
    return decorator

power = int(input('enter the exponent : '))

def random_odd_digit():
    return random.choice([3,5,7])

random_odd_digit = power_of(power)(random_odd_digit)

print(random_odd_digit())


builtin decorators:
-------------------
-->we previously used the built in decorators like @classmethod, @staticmethod. let's see how we can use them. the normal way of using them is using the '@' syntax. see below :

example:
--------
class A:

    @classmethod
    def hello(cls):
        return f'this is the static method'

print(A.hello())

output:
-------
this is the static method

-->let's write the above code without using '@' syntax. see below :

example:
--------
class A:
    
    def hello(cls):
        return f'this is the static method'

A.hello = classmethod(A.hello)
print(A.hello())

output:
--------
this is the static method

-->let's try the @staticmethod. see below 

example:
--------
class A:
    
    def hello():
        return f'this is the static method'

A.hello = staticmethod(A.hello)
print(A.hello())

output:
-------
this is the static method



task:
-----
s = 'AAABCADDE'

k = 3

value = len(s) //  k

print(value)


list1 = [[] for i in range(k)]

for i, j in zip(range(0, len(s), value), range(k)):
    for ch in s[i : i + value ]:        
        list1[j].append(ch)
    
print(list1)

list2 = [[] for i in range(k)]
for i in range(len(list1)):
    for j in list1[i]:
        if j not in list2[i]:
            list2[i].append(j)

for i in list2:
    print(''.join(i)) 




