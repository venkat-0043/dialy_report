
								
								slicing works different with mutable and immutable
								--------------------------------------------------

example: THIS IS VERY IMPORTANT
--------
-->The [:] syntax works for lists. However, there is an important difference between how this operation works with a list and how it works with a string.

If s is a string, s[:] returns a reference to the same object:

>>> s = 'foobar'
>>> s[:]
'foobar'
>>> s[:] is s
True

-->the main thing is the slicing works different way when comes to the mutable and the immutable data types. but when comes to the list it is different. see below : 
exmaple :
--------
a = [1,2,3]
print(a is a[:])

output:
-------
False

-->here the a and a[:], they both pointing to the different address. but when come to the string it is different. not only string, if you take any other immutable object, it works different way. let's take a look at the tuple : 
example:
--------
a = (1,2,3)
print(a is a[:])

output:
-------
True

-->here the 'a' and 'a[:]', they pointing the same address.

---------------------------------------------------------------------------------------------------------------

-->find a given number is armstrong number or not 

solution :
----------
def armstrong(number):
    total = 0
    for i in number:
        total = total + int(i) ** 3

    if int(number) == total:
        print(f'the number {number} is the armstrong number')
    else:
        print(f'the number {number} is not armstrong')

number = input('enter the number : ')

armstrong(number)


--------------------------------------------------------------------------------------------------------------

Task
Given an integer, , perform the following conditional actions:

If  is odd, print Weird
If  is even and in the inclusive range of 2 to 5, print Not Weird
If  is even and in the inclusive range of 6 to 20, print Weird
If  is even and greater than 20, print Not Weird

solution :
----------
def func(n):
    if n % 2 != 0:
        return 'wierd'
    elif n % 2 == 0:
        if n in range(2, 6):
            return 'not weird'
        elif n in range(6, 21):
            return 'weird'
        elif n > 20:
            return 'not weird'

print(func(int(input('enter the number : '))))

output:
-------
enter the number : 5
wierd


--------------------------------------------------------------------------------------------------------------

Minion game:
------------

Game Rules

Both players are given the same string, .
Both players have to make substrings using the letters of the string .
Stuart has to make words starting with consonants.
Kevin has to make words starting with vowels.
The game ends when both players have made all possible substrings.

Scoring
A player gets +1 point for each occurrence of the substring in the string .

For Example:
String  = BANANA
Kevin's vowel beginning word = ANA
Here, ANA occurs twice in BANANA. Hence, Kevin will get 2 Points.

solution:
---------
def minion(string):
    vowels = ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
    stuart_score = 0
    kevin_score = 0
    kevin_words = []
    stuart_words = []

    for i in range(len(string)):
        if string[i] not in vowels:
        	#this count the combinations based on the count like for 'hell' it takes h, he, hel, hell
            stuart_score += len(string[i : ])
            
        elif string[i] in vowels:
            kevin_score += len(string[i : ])
            
    print('stuart score is :',  stuart_score)
    print('kevin score is : ', kevin_score)

    if stuart_score > kevin_score:
        print('stuart wins')

    elif stuart_score < kevin_score:
        print('kevin wins')
        
    else:
        print('both wins')


minion(input('enter the string : '))

-->the above code can give you the number of combinations, but it don't print all the word combinations. below code prints all the details : 

solution : 
----------
def minion(string):
    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']
    stuart_score = 0
    kevin_score = 0
    kevin_words = []
    stuart_words = []

    for i in range(len(string)):
        if string[i] not in vowels:
            temp = string[i : ]
            #this count the combinations based on the count like for 'hell' it takes h, he, hel, hell
            stuart_score += len(string[i : ])
            for i in range(len(temp)):
                stuart_words.append(temp[0 : i + 1])
            
            
        elif string[i] in vowels:
            temp = string[i : ]
            #this count the combinations based on the count like for 'hell' it takes h, he, hel, hell
            kevin_score += len(string[i : ])
            for i in range(len(temp)):
                kevin_words.append(temp[0 : i + 1])
            
    print('stuart score is :',  stuart_score)
    print('\nstuart combination words :',  stuart_words)
    print('\nkevin score is : ', kevin_score)
    print('\nkevin combination words :', kevin_words)

    if stuart_score > kevin_score:
        print('\nstuart wins')

    elif stuart_score < kevin_score:
        print('\nkevin wins')
        
    else:
        print('\nboth wins')


minion(input('enter the string : '))

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



												29-12-2021
												----------


functions:
----------
-->the type of the function variable, it is always belogns to the class 'function', see below :

example:
--------
def func():
    pass

print(type(func))

output:
-------
<class 'function'>


-->if you check the return type of the function, then it will return "NoneType" if it is not returning anything, if it is return anything, then it return the data type of the returning values. see below : 

example:
--------
def func():
    pass

print(type(func()))

output:
-------
<class 'NoneType'>


-->for example if the function is returning the string, then the return type of the function is string. see below : 

example:
--------
def func():
    return 'hello world'

print(type(func()))

output:
-------
<class 'str'>


functions vs methods:
----------------------
-->if we write the function inside the class, then the type of that function is not 'class function'. see below :

example:
--------
class Hello:

    def func(self):
        pass

obj = Hello()
print(type(obj.func))

output:
--------
<class 'method'>

-->here, when we write the function inside the class, the type of that function variable is changed to 'class method'. if we don't write the function inside the class, then that' function variable's return type is 'class function'. this one of the way to identify the difference between the functions and methods. 


inner functions:
----------------
-->these are just function within another function, we can call them as the nested functions.

example:
--------
def outer():
    print('this is the outer function')
    def inner():
        print('this is the inner function')
    return inner()

outer()

output:
-------
this is the outer function
this is the inner function


encapsulation with inner functions:
-----------------------------------
-->A common use case of inner functions arises when you need to protect, or hide, a given function from everything happening outside of it so that the function is totally hidden from the global scope. This kind of behavior is commonly known as encapsulation.

example:
--------
def add(number):
    def inner():
        return number + 1
    return inner()

inner()

output:
-------
Traceback (most recent call last):
  File "C:\Users\this\Desktop\sample1.py", line 6, in <module>
    inner()
NameError: name 'inner' is not defined

-->here we can't access the inner function directly, because the outer function is hiding the inner function from accessing directly.


-->the inner function has access to the outer functions state.

example:
--------
def square(number):
    def inner(power):
        return number ** power
    return inner(2)

print(square(10))
    
output:
-------
100

-->here the inner function has the access to the outer function data 'number'. 

example : writing multiple nested functions
---------
def square(number):
    def outer(power):
        def inner():
            return number ** power
        return inner()
    return outer(2)

print(square(10))
    
output:
-------
100

-->here the 'inner' function has the access to the parameters of the outer functions outer and square.



recursion functions:
--------------------
-->a function which calls itself again and again. 

example: calculate the sum of first 10 numbers
--------
def func(number):
    if number == 1:
        return 1
    else:
        return number + func(number - 1)

print(func(20))

output:
-------
55


-->there is another way we can write the above program

example:
--------
def func(number):
    return number + func(number - 1) if number > 0 else 0 

print(func(5))

output:
--------
15


example: calculate the factorial of a number using recursion 
--------
def func(number):
    if number == 1:
        return 1
    else:
        return number * func(number - 1)

print(func(6))

output :
--------
720


functions are the fist class object:
------------------------------------
-->the functions in python are called as the first class objects, there are 4 main reasons : 
1)we can return a function from another function
2)we can pass the function as the argument to anothe function
2)we can store the return value of the function in a variable
4)we can create one function within another function

pass function as the argument:
------------------------------
example:
--------
def add():
    return 10 + 20

def result(add):
    value = add()
    return value

print(result(add))

output:
-------
30

-->here I passed the function 'add' as the argument to the function 'result'. we can also pass the anonymous functions 'lambda' as the argument to another function. see below :

example:
--------
def result(add):
    value = add()
    return value

print(result(lambda : 10 + 20))

output:
--------
30

-->we can also write the above program by simplye storing the lambda function in a variable and pass that variable. see below : 

example:
--------
def result(add):
    value = add()
    return value

value = lambda : 10 + 20
print(result(value))

output:
-------
30


-->let's prints numbers from 1 to 10, by passing the function as the argument in the list comprehension
example:
--------
def func():
    return 10

print([i for i in range(func())])

output:
-------
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]




Task:
-----
-->in the below list, find the names with maximum marks and sorted the names

solution:
---------
data = [['b', 10], ['c', 20], ['a', 20]]

names = []
marks = []

for i, j in data:
    names.append(i)
    marks.append(j)

max_marks = max(marks)

list1 = []

for i, j in data:
    if j == max_marks:
        list1.append(i)

print(sorted(list1))

output:
-------
['a', 'c']


Task:
-----
-->sort dictionary based on values:

solution:
---------
data = [['b', 10], ['a', 20], ['c', 20]]

names = []
marks = []
dict1 = {}

for i, j in data:
    dict1[i] = j

for i, j in dict1.items():
    value = max(dict1.values())
    if j == value:
        print(i)

output:
-------
a
c


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

												Decorators(3-1-2022)
												--------------------

-->the decorators pattern is an object oriented design pattern that allows behaviour to be added to an existing object dynamically. when you decorate an object then you extend it's functionality in a way that is independet of other instances of the same class.

-->python decorators add functionality to functions and methods at the definitions time, they are not used to add the functinality at run time.

-->we have 2 types of decorators in python. decorators can be applied to both functions and classes.
1)function decorator
2)class decorator


function decorator:
-------------------
-->to implement the function decorator, we need 2 functions. one function is to take the decorator function as the argument and an inner function to call the decorator function. first let's see how the inner functions works. 

example:
--------
def outer():
    print('this is the outer function')
    def inner():
        print('this is the inner function')
    return inner

print(outer())

output:
-------
this is the outer function
<function outer.<locals>.inner at 0x0000000002D74670>

-->here it returned the function object, the reason is the return value of the outer() is 'inner' which is the function variable. if you print the function variable, it will give you the address. here the inner() is not called, you can call it in the return statement. see below : 

example:
--------
def outer():
    print('this is the outer function')
    def inner():
        print('this is the inner function')
    return inner()

print(outer())

output:
-------
this is the outer function
this is the inner function
None

-->here it returns the 'None', the reason is the inner function is not returning anything. if the functions is not returnig anything it's return value is None. 

-->let's taka look at the sample decorator : 

example:
--------
def decorator(func):
    print('this is the decorator function')
    def inner():
    	
        print('this is the inner function')
        func()
        
    return inner

@decorator
def main():
    print("this is the main function ")

main()

output:
-------
this is the decorator function
this is the inner function
this is the main function 

-->here the we have the decorator function 'decorator'. main() is the decorated function. the 'decorator' function takes the 'main' as the argument. her func = main. the reason why we have the 'inner' function is, it called the 'main' function.

-->actually this is the new style of implementing the function decorators. before '@' was introduced, there is another way to invoke the decorators. see below : 

example:
--------
def decorator(func):
    print('this is the decorator function')
    def inner():    	
        print('this is the inner function')
        func()
        
    return inner


def main():
    print("this is the main function ")

main = decorator(main)

main()

output:
-------
this is the decorator function
this is the inner function
this is the main function 

-->here instread of using the '@' symbol, we invoked the decorator in the old style. here 'decorator(main)' calls the decorator function with 'main' as the argument. the return value of the 'decorator(func) is 'inner'. now the main is point to the 'inner'. so when you call the main(), it calls the inner() functions.

-->we can decorator many functions using the single decorator. see below : 

exmaple:
--------
def decorator(func):
    def inner():
        print('this is the function : ', func.__name__)
    return inner

@decorator
def func1():
    print('this is func1')

@decorator
def func2():
    pass

func1()
func2()

output:
-------
this is the function :  func1
this is the function :  func2

-->here we decorated the 2 functions func1 and func2. when you call func1(), func(2), they calls the inner function 2 times. 

-->let's write the above progrma without using the '@decorator'. see below : 

example:
---------
def decorator(func):
    def inner():
        print('this is the function : ', func.__name__)
    return inner


def func1():
    print('this is func1')

func1 = decorator(func1)
func1()


def func2():
    pass

func2 = decorator(func2)
func2()

output:
-------
this is the function :  func1
this is the function :  func2


-->we can write the nested decorators also. see below :
example:
--------
def first_dec(func):
    def inner():
        print('this is the first decorator')
        return func()
    return inner

def second_dec(func):
    def inner():
        print('this is the second decorator')
        return func()
    return inner

@first_dec
@second_dec
def main():
    print('this is the main function')

main()

output:
-------
this is the first decorator
this is the second decorator
this is the main function

-->here the inner decorator executes first, then the outer decorator executes, then finally the main() function is called. let's write this code without using '@decorator'.

example:
--------
def first_dec(func):
    def inner():
        print('this is the first decorator')
        return func()
    return inner

def second_dec(func):
    def inner():
        print('this is the second decorator')
        return func()
    return inner

def main():
    print('this is the main function')

main = first_dec(second_dec(main))

main()

output:
-------
this is the first decorator
this is the second decorator
this is the main function


@wraps:
-------
-->there is one flaw in code written above. see below : 

example:
--------
def decorator(func):
    def inner():
        print('this is the inner function : ', func.__name__)
        func()
    return inner

@decorator
def main():
    print('this is the main function')

main()
main()

output:
-------
this is the inner function :  main
this is the main function
this is the inner function :  main
this is the main function

-->here every time we call the main() function, it is not calling the main() function, it is called the inner() function. the reason is the main function variable 'main' is pointing to the inner() function variable 'inner'. but this is not how it should be. the function variable 'main' should always pointing to it's function main(). so avoid that we have to use the other decorator '@wraps' from the 'functools' module. see below : 

example:
--------
from functools import wraps
def decorator(func):
    @wraps(func)
    def inner():
        print('this is inner function : ', func.__name__)
        func()
    return inner

@decorator
def main():
    print('this is the main function')

main()

-->For the decorator '@wraps(func)', we have to pass the function variable for which we want to do dereferencing. here the 'func' contains 'main', so @wraps(func) make the referencing, so that after the execution of the above code main is no longer points to the 'inner' function. 
'

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


										       04-01-2022
											----------

class decorators:
-----------------
-->a decorator can not only be a function, it can also be a class. when compared to the execution flow, the class decorators are bit different from the function decorators. see below :

example:
--------
class entry_exit():

    def __init__(self, f):
        self.f = f

    def __call__(self):
        print('entering into the ', self.f.__name__)
        self.f()
        print('exiting the function', self.f.__name__)

@entry_exit
def func1():
    print('inside func1')

@entry_exit
def func2():
    print('inside func2')

func1()
func2()

-->here when the control hits the '@entry_exit', it calls the '__init__()' constructor, with function variable 'func1' as the argument. so in the __ini__(self, f), f contains the 'func1'. the samething applicable for the function 'func2'. when func1() and func2() is called, internally '__call__()' method will be called, here we override the dunder __call__() method. this method will call the main functions 'func1' and 'func2'. 

-->while working with the functiond decorators, we invoked the decorator without using the '@' syntax. for the class decorators also we can invoke them without using the '@'. see below : 

example:
--------
class Entry_exit():

    def __init__(self, f):
        self.f = f

    def __call__(self):
        print('before the function : ', self.f.__name__)
        self.f()
        print('after the function : ', self.f.__name__)

def func1():
    print('this is the func1')

func1 = Entry_exit(func1)

def func2():
    print('this is the func2')

func2 = Entry_exit(func2)

func1()
func2()

output:
-------
before the function :  func1
this is the func1
after the function :  func1
before the function :  func2
this is the func2
after the function :  func2


-->the reason why the class decorator class the __init__() method is, the syntax 'func2 = Entry_exit(func2)', here the 'Entry_exit(func2)', is like the object instantiation syntax. so when instantiation happens, it calls the __init__() constructor immediately.

-->here the syntax 'func1 = Entry_exit(func1)', you may get the doubt that, func1 could be the object. actually here func1 represents the object as well as the function variable. so here 'self' represents the object as well as the function variable. so you can call like 'self()'. it dont' give error, but it goes into the infinite loop. because every time you call self(), it calls the __call__() method, again self() is called, again __call__() is executed. so avoid this practice. see below code : 

example:
--------
class Entry_exit():

    def __init__(self, f):
        self.f = f

    def __call__(self):
        print('before the function : ', self.f.__name__)
        self()
        print('after the function : ', self.f.__name__)

def func1():
    print('this is the func1')

func1 = Entry_exit(func1)

def func2():
    print('this is the func2')

func2 = Entry_exit(func2)

func1()
func2()

-->this code goes into infinite loop.


decorators with arguments:
--------------------------
-->we can pass the arguments to the function decorators. for writing the decorators with arguments, you need to have 2 inner functions. see below : 

example:
--------
import random
def power_of(exponent):
    def decorator(func):
        def inner():
            return func() ** exponent
        return inner
    return decorator

power = int(input('enter the exponent : '))

@power_of(power)
def random_odd_digit():
    return random.choice([3,5,7])

print(random_odd_digit())

output:
-------
enter the exponent : 2
9

-->here the reason why we have 3 functions in the decorator is, the outer function will take the argument, next the decorator function takes the function as the argument and the inner function is used to call the main function or decorated function. let's write the above code without using the '@' syntax : 

example:
---------
import random
def power_of(exponent):
    def decorator(func):
        def inner():
            return func() ** exponent 
        return inner
    return decorator

power = int(input('enter the exponent : '))

def random_odd_digit():
    return random.choice([3,5,7])

random_odd_digit = power_of(power)(random_odd_digit)

print(random_odd_digit())


builtin decorators:
-------------------
-->we previously used the built in decorators like @classmethod, @staticmethod. let's see how we can use them. the normal way of using them is using the '@' syntax. see below :

example:
--------
class A:

    @classmethod
    def hello(cls):
        return f'this is the static method'

print(A.hello())

output:
-------
this is the static method

-->let's write the above code without using '@' syntax. see below :

example:
--------
class A:
    
    def hello(cls):
        return f'this is the static method'

A.hello = classmethod(A.hello)
print(A.hello())

output:
--------
this is the static method

-->let's try the @staticmethod. see below 

example:
--------
class A:
    
    def hello():
        return f'this is the static method'

A.hello = staticmethod(A.hello)
print(A.hello())

output:
-------
this is the static method



task:
-----
s = 'AAABCADDE'

k = 3

value = len(s) //  k

print(value)


list1 = [[] for i in range(k)]

for i, j in zip(range(0, len(s), value), range(k)):
    for ch in s[i : i + value ]:        
        list1[j].append(ch)
    
print(list1)

list2 = [[] for i in range(k)]
for i in range(len(list1)):
    for j in list1[i]:
        if j not in list2[i]:
            list2[i].append(j)

for i in list2:
    print(''.join(i)) 


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


                                                05-01-2022
                                                ----------

requiremnt :
-------------
-->take a string, generate all combinations of the substring. the substring should not have the duplicate characters. return the longest substring which don't have the duplicate characters.

solution:
---------
string = 'abdfdddgee'


set1 = set()
length = len(string)

for i in range(length + 1):
    for j in range(i, length + 1):
        set1.add(string[i : j ])


set1.remove('')
print(set1)

set2 = set()
for i in set1:
    result = ''
    for j in i:
        if j in i and i.count(j) == 1:
            result = result + j
            set2.add(result)
            
print(set2)

dict1 = dict()

for i in set2:
    dict1[i] = len(i)

count = max(dict1.values())
print(count)

for key, value in dict1.items():
    if value == count:
        print(key)



files:
------
-->to work with files we use method open() to open the files. by default the open() method opens the file in teh read mode. the open() method return the file object. see below :

example:
--------
print(open('sample.txt'))

output:
-------
<_io.TextIOWrapper name='sample.txt' mode='r' encoding='cp1252'>

-->this file object is iterable. to get the data we can loop over this file object. see below :

example:
--------
f = open('sample.txt')
for i in f:
    print(i)

output:
-------
hello world

this is python

how are you

-->If you check the output, it adds the new line after every line. this is simply putting a new line character after every line. to avod the new line, use the end = ''. see below : 

example:
--------
f = open('sample.txt')
for i in f:
    print(i, end = '')

output:
-------
hello world
this is python
how are you

-->if you use the open() method, we have to close the file manually usign the method close(). once the file is closed, we can access the file object, but we can't loop over the file object. see below :

example:
--------
f = open('sample.txt')
for i in f:
    print(i, end = '')

f.close()

for i in f:
    print(i)

output:
-------
hello world
this is python
how are youTraceback (most recent call last):
  File "C:\Users\this\Desktop\sample1.py", line 7, in <module>
    for i in f:
ValueError: I/O operation on closed file.


-->to check if the file is closed or not closed, we can use the file attribute 'closed'. this returns true or false. see below : 

example:
--------
f = open('sample.txt')
for i in f:
    print(i, end = '')
    
print('\n',f.closed)

f.close()

print('\n', f.closed)

output:
-------
hello world
this is python
how are you
 False

 True

 -->to read the data from the file object, we have some other methods read(), readline(), readlines().

 read():
 -------
 -->the read() method reads the whole data at once.

 example:
 --------
f = open('sample.txt')
print(f.read())

output:
-------
hello world
this is python
how are you

-->if you loop over the f.read(), you will get the data character by character. see below :

example:
--------
f = open('sample.txt')
for i in f.read():
    print(i)

output:
-------
h
e
l
l
o
 
w
o
r
l
d

-->the reason why this printing character by character is, the read() method reads all data at once in the form of string. if you loop over a string, you will get the each individual character from the string. 


readline():
------------
-->the readline() method reads the one line at a time. see below :

example:
--------
f = open('sample.txt')
print(f.readline())

output:
-------
hello world

>>>

-->Here it print the new line after the line. the reason the readline() add the new line character at the end of the line it reads. to get all the data, we can't write this statement again and again. for that we the method readlines():

readlines():
------------
-->the readlines() method reads the all the data line by line and add them into the list. see below :

example:
--------
f = open('sample.txt')
print(f.readlines())

output:
-------
['hello world\n', 'this is python\n', 'how are you']

-->here each line is stored as the item of list in the string format. it adds the new line character at the end of the each line. when it finds the last line it don't add the new line. to get the individual line use the for loops. see below : 

example:
--------
f = open('sample.txt')
for i in f.readlines():
    print(i)

output:
-------
hello world

this is python

how are you


-->with these 3 methods, we can read how many characters we want using the attribute 'size'. see below :

example:
--------
f = open('sample.txt')
print(f.read(10))

output:
-------
hello worl

-->here I readed the first 10 characters from the file. by default the size = -1, which means all the data.

-->the the problem with the open() method is we have to close the file manually every time we open the file. To avoid that we use the context managers. any statement the contains the 'with' is the context manager. so that when we exit the with block,it automatically close the file connection. it also works with socket connections also. 

example:
--------
with open('sample.txt') as f:
    for i in f.readlines():
        print(i)

output:
-------
hello world

this is python

how are you




-------------------------------------------------------------------------------------------------------------


                                            06-01-2022
                                            ----------


writing the data into the file:
-------------------------------
-->to write the data into the file we need to open the file the write mode, where we have mention like mode = 'w'.

example:
--------
with open('sample.txt', mode = 'w') as f:
    f.write('this is the new line')


-->this opens the file in the write mode and write the line'this is the new line' into the file. if we try to print the result of this operation it simply prints the number of characters it writes into the file. see below : 

example:
--------
with open('sample.txt', mode = 'w') as f:
    print(f.write('this is the new line'))

output:
-------
20

-->here it prints 20, because it writes 20 characters into the file. the write operation return the integer values. but while writing it removes the data and overrides the existing data. at that time open the file in the append mode.

-->once we open the file in the write mode, we can't read that file. we can only write into the file. otherwise we get the error. see below :

example:
--------
with open('sample.txt', mode = 'w') as f:
    print(f.write('this is the new line'))
    print(f.read())

output:
-------
20
Traceback (most recent call last):
  File "C:\Users\this\Desktop\sample1.py", line 3, in <module>
    print(f.read())
io.UnsupportedOperation: not readable


-->if we want to open the file in both read and write mode use mode = 'r+'. see below :

exmaple:
--------
f = open('sample.txt', mode = 'r+')
print(f.write('new line added'))
print(f.read())

output:
-------
14
w line

-->here this write the 14 characters, so it returns 14. But when we read the data it just prints 'w line'. the reason is , previously  have another line 'this is the new line', this is overridden by the new line 'new line added'. since the previous line is big, the 'new line added' was not able to override previous line. but it overridden till 14 character and cursor was waiting at the 14th character. so when we read the file, the cursor was at 14th character, when read it, it is printing the data which is after the 14th character.


-->to know exactly where the cursor is pointing, we use the method tell(). this returns the integer. see below :

example:
--------
f = open('sample.txt', mode = 'r+')
print(f.write('new line added'))
print(f.tell())

output:
-------
14
14

-->here it returns the 14, because the cursor is waiting at the 14th position. we can use the seek() method to cursor whevever we want. this means we can customize the reading position. see below : 

example:
--------
f = open('sample.txt', mode = 'r+')
print(f.write('new line added'))

f.seek(0)

print(f.read())

output:
-------
14
new line addedw line

-->here seek(0) means, put the reading position at the start. the return value of the seek() method is an integer. which means it returns at which character it is placing the cursor. see below : 

example:
--------
f = open('sample.txt', mode = 'r+')
print(f.write('new line added'))

print(f.seek(0))
print(f.read())

print(f.seek(5))
print(f.read())

output:
-------
14
0
new line addedw line
5
ine addedw line


writing from a file:
--------------------
-->we can read the data from a file and write that data into anothe file. for that we need to open the 2 files. see below : 

example:
--------
with open('sample.txt') as f:
    with open('sample1.txt', mode = 'r+') as g:
        g.write(f.read())
        print(g.read())

output:
-------


-->here I read the data from file sample.txt and write that data into sample1.txt. then I read the data from the file sample1.txt, but it is not printing anything. the reason is , the cursor position is at the end of the file. so read from the begining just use the seek(0), then read the file. see below :

example:
--------
with open('sample.txt') as f:
    with open('sample1.txt', mode = 'r+') as g:
        g.write(f.read())
        g.seek(0)
        print(g.read())

output:
-------
hello world
this is python


-->here we can use the methods readline() and readlines() also.


appending the data:
-------------------
-->previously when we writing into the file, it is overriding the data. to avoid that we use mode = 'a', where it adds the new at the end of the existing data. see below : 

example:
--------
with open('sample.txt', mode = 'a+') as f:
    f.write('this is the new line')
    print(f.read())

output:
-------


-->this also returns nothing. becuase it appends the new line at end of the file, so cursor is again at the end of the line. so use seek(0). see below : 

example:
--------
with open('sample.txt', mode = 'a+') as f:
    f.write('this is the new line')
    f.seek(0)
    print(f.read())

output:
-------
hello world
this is python
this is the new line


exclusive mode:
---------------
-->when you open a non existing file in exclusive mode, it creates a new file, it the file already exists, it returns error. see below : 

example:
--------
with open('sample2.txt', mode = 'x') as f:
    print(f)

output:
-------
<_io.TextIOWrapper name='sample2.txt' mode='x' encoding='cp1252'>

-->here there is not file named 'sample2.txt', so it creates the new file and the operation is successful. if we run this code for the second time, it throws the exception. 

example:
--------
with open('sample2.txt', mode = 'x') as f:
    print(f)

output:
-------
Traceback (most recent call last):
  File "C:\Users\this\Desktop\sample1.py", line 1, in <module>
    with open('sample2.txt', mode = 'x') as f:
FileExistsError: [Errno 17] File exists: 'sample2.txt'



-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



 									08-01-2022
                                            				----------

Exceptions:
-----------
-->exceptions are the run time error. even though the syntax is correct, due to some logical error, it will stops the execution and raises the exception. examples are like ZeroDivision, StopIteration, ArithmeticError etc.

example:
--------
print(10/0)

output:
-------
Traceback (most recent call last):
  File "C:\Users\this\Desktop\sample1.py", line 1, in <module>
    print(10/0)
ZeroDivisionError: division by zero

-->here this raise the zerodivisionerror, because anything divide with zero is infinity. In exceptions we have 3 blocks. 

1)try
2)catch
3)finally

-->whatever the block of code or statement might causing the exception, we write that block of code in the try block. it any exception is raised it will be catched in the 'catch' block. the 'finally' block will executes irrelavent of wether the exception is raised or not. 'finally' block is useful tell you that you reached the end of the excecution. 

-->let's catch the zerodivisionerror exception : 

example:
--------
try:
    print(10/0)

except ZeroDivisionError:
    print('exception is raised')

output:
-------
exception is raised


-->here we used the relavent exception. what if we don't know the exact exception, use the parent exception "Exception". see below :

example:
--------
try:
    print(10/0)

except Exception:
    print('exception is raised')

output:
-------
exception is raised

-->here there is a problem with this. we don't know the exactly what kind of exception we are getting. at that time use the 'Exception' class object. see below :

example:
--------
try:
    print(10/0)

except Exception as e:
    print('exception is raised is : ', e)

output:
-------
exception is raised is :  division by zero


multiple except blocks:
-----------------------
-->we can write the multiple 'except' blocks. so that the relavent exception will catched. see below : 

example:
--------
string = 'hello'

try:
    value = int(string)

except TypeError:
    print('type of string is incopatible')

except ValueError:
    print('only accepts the integer')

finally:
    print('finished execution')

output:
-------
only accepts the integer
finished execution

-->here the first exception is not catched, second exception is catched. there is another way to write the above code. see below : 

example:
--------
string = 'hello'

try:
    value = int(string)

except (TypeError, ValueError):
    print("enter the correct value")

output:
-------
enter the correct value


-->The problem with this is, we don't know exactly which exception it is catching. if you want to know which exception is raising, us the 'as' keyword to get the exception object. see below :

example:
--------
string = 'hello'

try:
    value = int(string)

except (TypeError, ValueError) as e:
    print(e)
    print(type(e))
    print("enter the correct value")

output:
-------
invalid literal for int() with base 10: 'hello'
<class 'ValueError'>
enter the correct value


-->if you print the exception object it simply prints the exception message. to know which exception is raised exactly, just use type(e). the reason is 'e' will the object of the exception which is raised. so if print the type of that object, it will simply returns it's class name(exception name).


exceptions hierarchy:
---------------------
-->always write the subclass exceptions at the begining and the super class excpetions at the end in a hierarchical manner. see the below 

example:
--------
x = 10
y = 'string'
try :

    result = x / y

except ZeroDivisionError as zde:
    print(type(zde), zde)

except ValueError as ve:
    print(type(ve), ve)

except Exception as e:
    print('super class exception is called')
        
output:
-------
super class exception is called

-->here when there is no relevant exception is catched, the super class excpetion 'Exception' catches that exception. if we write the super class exception at the begining it catches all the exceptions. control never goes to the other exceptions in the block. see below : 

example:
--------
x = 10
y = 0
try :

    result = x / y
    
except Exception as e:
    print('super class exception is called')

except ZeroDivisionError as zde:
    print(type(zde), zde)

except ValueError as ve:
    print(type(ve), ve)


output:
-------
super class exception is called


-->here the syntax 'result = x / y' raises the 'zerodivisionerror', even though the we have provided the relavent exception, it was caught by the super class 'Exception'. so whatever the exception is raised it will be caught by the super class 'Exception' in the early stages. to make this program more readable, use the object of the exception class. see below : 

example:
--------
x = 10
y = 0
try :

    result = x / y
    
except Exception as e:
    print('super class exception :', e)

except ZeroDivisionError as zde:
    print(type(zde), zde)

except ValueError as ve:
    print(type(ve), ve)

output:
-------
super class exception : division by zero


Aliasing:
---------
-->notice the following line in the code above :

except (exception 1, excpetion 2, ..) as e:

-->that is the exceptions are being given a name. technically, it is called 'aliasing'. with aliasing, we can access the exceptions with a common name. this is useful if you want to use attributes of the exception being handled. aliasing is done through the 'as' keyword. the syntax is : 

try : 
    # try code

except (exception_1, exception_2,..) as <alias>:

    # exception handling here
    # you can access attributes of exceptions being handled through it's alias <alias>


example:
--------
try:
    raise NameError('undefined name')

except (NameError, ValueError) as er:
    print('NameError exception was raised')

output:
-------
NameError exception was raised

-->you can use any name for the alias(but definitely not the built-in keyword), usually 'e' is just a popular one.


Finally clause:
---------------
-->the 'try' statement has one last clause 'finally', which is basically used for clean up actions. when used, it should follow all other clauses. 'finally' clause is executed in any even irrespective of whether an exception has occurred or not. 'finally' clause does not strictly need to the 'else' or 'except' clause to be present. see below : 

example:
--------
def func(a, b):
    try:
        output = a / b

    except ZeroDivisionError:
        print('zerodivisionerror raised')

    else :
        print('the result is  : ',output)

    finally:
        print('program ended')

func(10, 0)
func(10, 2)

output:
-------
zerodivisionerror raised
program ended
the result is  :  5.0
program ended







patterns:
---------
-->print the below patterns

a
a c
a c e
a c e g

solution:
---------
list1 = [chr(i) for i in range(97, 104)]
print(list1)

for i in range(0, len(list1), 2):
    print(' '.join(list1[0 : i + 1 : 2]))


-->print the below pattern
[1]
[1][2]
[1][2][3]
[1][2][3][4]
[1][2][3][4][5]

solution:
---------
for i in range(1, 6):
    print()
    for j in range(1, i + 1):
        print(f'[{j}]', end = '')


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




requirement:
------------
you are given a string S of size N. you need to find the number of subsequences of string S that can be made palindrome by rearranging. Since the answer can be large return it moduel 10 **(9 + 7).

Note : 
------
S only contains lowercase english alphabets. an empy sebsequence is always a palindrome.

input format:
--------------
-->the first line contains an integer, N, denoting the size of the string A.
-->The next line contains a string, S, denoting the string S.

sample input:
-------------
bb --> result should be 4
bab --> result should be 6
aaccb --> result should be 16

solution:
---------

string = 'aaccb'
list1 = ['']
import itertools as it

for i in range(1, len(string) + 1):
     for j in it.combinations(string, i):
         for k in set(it.permutations(j)):
            result = ''.join(k)
            print(result)
            if result == result[::-1]:
                list1.append(result)

for i in list1:
    if len(i) > 2:
        if list1.count(i) > 1:
            list1.remove(i)

print(list1, len(list1))



requirement 2:
--------------

solution :
----------
import itertools as it
list1 = [1,3,2,5]

n = 2

for i in it.combinations(list1, n):
    print(i)



Generators:
-----------
-->before we go with generators, we need to understand the iterable and iterators.

iterable : iterable is any object we iterate over it using the for loop. they are not always indexible. sometimes they are finite, sometimes they are infinite.

-->Here's is infinite iterable which provides every multiple of 5 as you loop over it.

example:
--------
from itertools import count
result = count(step = 5)
print(result)

output:
--------
count(0, 5)

-->here this returns iterator object which can be iterable. if we use the for loop to get the elements from this, it goes into the infinite loop.

example:
--------
from itertools import count
result = count(step = 5)
print(result)

#this causes the infinite loop.
for i in result:
    print(i)


-->to avoid that use the loop variable or condition to control the incrementation. see below : 

example:
--------
from itertools import count
result = count(step = 5)
print(result)

for i in result:
    if i <= 40:
        print(i)

output:
-------
count(0, 5)
0
5
10
15
20
25
30
35
40


iterators:
----------
-->Iterator is an object used to iterator over the iterable objects like list, set, string, dictionary. The iterator object is initialized using the iter() method. This method raises the 'StopIteration' exception to signal the end of the iteration. let's create one iterator. see below : 

example:
--------
result = iter(['hello', 'world'])

print(result)

print(next(result))
print(next(result))

output:
-------
<list_iterator object at 0x0000000002D02EB0>
hello
world

-->here I passed the iterable to an iter() method to create the iterator. we can say iterator are the object which we can loop over or use the next() method to get the element from the. so all the iterators are iterables. if there is no elements in the iterator to read, it raises the StopIteration exception. see below:

examaple:
---------
result = iter(['hello', 'world'])

print(result)

print(next(result))
print(next(result))
print(next(result))

output:
-------
<list_iterator object at 0x0000000002D01EB0>
hello
world
Traceback (most recent call last):
  File "C:\Users\this\Desktop\sample1.py", line 7, in <module>
    print(next(result))
StopIteration


-->sometimes use the for loops for the iterators. because they handle the StopIteration exceptions in some occasions. see below : 

example:
--------
<list_iterator object at 0x0000000002D02EB0>
hello
world








requirement : 
--------------
-->given a list of elements, find the triplets where the sum of all elements in that triplets is 0.

solution:
----------
lst = [-1, 0, 1, 2, -1, -4]
#output = [[-1, -1,2], [-1, 0, 1]]

length = len(lst)
result = []

for i in range(length):
    for j in lst[i+1 : ]:
        for k in lst[j + 1 : ]:
            if i + j + k == 0:
                result.append([i, j, k])

print(result)

output:
-------
[[0, 0, 0], [0, 1, -1], [0, -1, 1], [1, -1, 0], [2, 2, -4], [2, -1, -1], [2, -1, -1], [2, -4, 2]]


solution 2:(not complete solution)
-----------
import itertools as it

list1 = []

for i in it.combinations(lst, 4):
    print(i)
    if sum(i) == 0:
        
        list1.append(i)

print(list1)

output:
-------
[(-1, 0, 1), (-1, 2, -1), (0, 1, -1)]
