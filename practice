
								
								slicing works different with mutable and immutable
								--------------------------------------------------

example: THIS IS VERY IMPORTANT
--------
-->The [:] syntax works for lists. However, there is an important difference between how this operation works with a list and how it works with a string.

If s is a string, s[:] returns a reference to the same object:

>>> s = 'foobar'
>>> s[:]
'foobar'
>>> s[:] is s
True

-->the main thing is the slicing works different way when comes to the mutable and the immutable data types. but when comes to the list it is different. see below : 
exmaple :
--------
a = [1,2,3]
print(a is a[:])

output:
-------
False

-->here the a and a[:], they both pointing to the different address. but when come to the string it is different. not only string, if you take any other immutable object, it works different way. let's take a look at the tuple : 
example:
--------
a = (1,2,3)
print(a is a[:])

output:
-------
True

-->here the 'a' and 'a[:]', they pointing the same address.

---------------------------------------------------------------------------------------------------------------

-->find a given number is armstrong number or not 

solution :
----------
def armstrong(number):
    total = 0
    for i in number:
        total = total + int(i) ** 3

    if int(number) == total:
        print(f'the number {number} is the armstrong number')
    else:
        print(f'the number {number} is not armstrong')

number = input('enter the number : ')

armstrong(number)


--------------------------------------------------------------------------------------------------------------

Task
Given an integer, , perform the following conditional actions:

If  is odd, print Weird
If  is even and in the inclusive range of 2 to 5, print Not Weird
If  is even and in the inclusive range of 6 to 20, print Weird
If  is even and greater than 20, print Not Weird

solution :
----------
def func(n):
    if n % 2 != 0:
        return 'wierd'
    elif n % 2 == 0:
        if n in range(2, 6):
            return 'not weird'
        elif n in range(6, 21):
            return 'weird'
        elif n > 20:
            return 'not weird'

print(func(int(input('enter the number : '))))

output:
-------
enter the number : 5
wierd


--------------------------------------------------------------------------------------------------------------

Minion game:
------------

Game Rules

Both players are given the same string, .
Both players have to make substrings using the letters of the string .
Stuart has to make words starting with consonants.
Kevin has to make words starting with vowels.
The game ends when both players have made all possible substrings.

Scoring
A player gets +1 point for each occurrence of the substring in the string .

For Example:
String  = BANANA
Kevin's vowel beginning word = ANA
Here, ANA occurs twice in BANANA. Hence, Kevin will get 2 Points.

solution:
---------
def minion(string):
    vowels = ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
    stuart_score = 0
    kevin_score = 0
    kevin_words = []
    stuart_words = []

    for i in range(len(string)):
        if string[i] not in vowels:
        	#this count the combinations based on the count like for 'hell' it takes h, he, hel, hell
            stuart_score += len(string[i : ])
            
        elif string[i] in vowels:
            kevin_score += len(string[i : ])
            
    print('stuart score is :',  stuart_score)
    print('kevin score is : ', kevin_score)

    if stuart_score > kevin_score:
        print('stuart wins')

    elif stuart_score < kevin_score:
        print('kevin wins')
        
    else:
        print('both wins')


minion(input('enter the string : '))

-->the above code can give you the number of combinations, but it don't print all the word combinations. below code prints all the details : 

solution : 
----------
def minion(string):
    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']
    stuart_score = 0
    kevin_score = 0
    kevin_words = []
    stuart_words = []

    for i in range(len(string)):
        if string[i] not in vowels:
            temp = string[i : ]
            #this count the combinations based on the count like for 'hell' it takes h, he, hel, hell
            stuart_score += len(string[i : ])
            for i in range(len(temp)):
                stuart_words.append(temp[0 : i + 1])
            
            
        elif string[i] in vowels:
            temp = string[i : ]
            #this count the combinations based on the count like for 'hell' it takes h, he, hel, hell
            kevin_score += len(string[i : ])
            for i in range(len(temp)):
                kevin_words.append(temp[0 : i + 1])
            
    print('stuart score is :',  stuart_score)
    print('\nstuart combination words :',  stuart_words)
    print('\nkevin score is : ', kevin_score)
    print('\nkevin combination words :', kevin_words)

    if stuart_score > kevin_score:
        print('\nstuart wins')

    elif stuart_score < kevin_score:
        print('\nkevin wins')
        
    else:
        print('\nboth wins')


minion(input('enter the string : '))

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



												29-12-2021
												----------


functions:
----------
-->the type of the function variable, it is always belogns to the class 'function', see below :

example:
--------
def func():
    pass

print(type(func))

output:
-------
<class 'function'>


-->if you check the return type of the function, then it will return "NoneType" if it is not returning anything, if it is return anything, then it return the data type of the returning values. see below : 

example:
--------
def func():
    pass

print(type(func()))

output:
-------
<class 'NoneType'>


-->for example if the function is returning the string, then the return type of the function is string. see below : 

example:
--------
def func():
    return 'hello world'

print(type(func()))

output:
-------
<class 'str'>


functions vs methods:
----------------------
-->if we write the function inside the class, then the type of that function is not 'class function'. see below :

example:
--------
class Hello:

    def func(self):
        pass

obj = Hello()
print(type(obj.func))

output:
--------
<class 'method'>

-->here, when we write the function inside the class, the type of that function variable is changed to 'class method'. if we don't write the function inside the class, then that' function variable's return type is 'class function'. this one of the way to identify the difference between the functions and methods. 


inner functions:
----------------
-->these are just function within another function, we can call them as the nested functions.

example:
--------
def outer():
    print('this is the outer function')
    def inner():
        print('this is the inner function')
    return inner()

outer()

output:
-------
this is the outer function
this is the inner function


encapsulation with inner functions:
-----------------------------------
-->A common use case of inner functions arises when you need to protect, or hide, a given function from everything happening outside of it so that the function is totally hidden from the global scope. This kind of behavior is commonly known as encapsulation.

example:
--------
def add(number):
    def inner():
        return number + 1
    return inner()

inner()

output:
-------
Traceback (most recent call last):
  File "C:\Users\this\Desktop\sample1.py", line 6, in <module>
    inner()
NameError: name 'inner' is not defined

-->here we can't access the inner function directly, because the outer function is hiding the inner function from accessing directly.


-->the inner function has access to the outer functions state.

example:
--------
def square(number):
    def inner(power):
        return number ** power
    return inner(2)

print(square(10))
    
output:
-------
100

-->here the inner function has the access to the outer function data 'number'. 

example : writing multiple nested functions
---------
def square(number):
    def outer(power):
        def inner():
            return number ** power
        return inner()
    return outer(2)

print(square(10))
    
output:
-------
100

-->here the 'inner' function has the access to the parameters of the outer functions outer and square.



recursion functions:
--------------------
-->a function which calls itself again and again. 

example: calculate the sum of first 10 numbers
--------
def func(number):
    if number == 1:
        return 1
    else:
        return number + func(number - 1)

print(func(20))

output:
-------
55


-->there is another way we can write the above program

example:
--------
def func(number):
    return number + func(number - 1) if number > 0 else 0 

print(func(5))

output:
--------
15


example: calculate the factorial of a number using recursion 
--------
def func(number):
    if number == 1:
        return 1
    else:
        return number * func(number - 1)

print(func(6))

output :
--------
720


functions are the fist class object:
------------------------------------
-->the functions in python are called as the first class objects, there are 4 main reasons : 
1)we can return a function from another function
2)we can pass the function as the argument to anothe function
2)we can store the return value of the function in a variable
4)we can create one function within another function

pass function as the argument:
------------------------------
example:
--------
def add():
    return 10 + 20

def result(add):
    value = add()
    return value

print(result(add))

output:
-------
30

-->here I passed the function 'add' as the argument to the function 'result'. we can also pass the anonymous functions 'lambda' as the argument to another function. see below :

example:
--------
def result(add):
    value = add()
    return value

print(result(lambda : 10 + 20))

output:
--------
30

-->we can also write the above program by simplye storing the lambda function in a variable and pass that variable. see below : 

example:
--------
def result(add):
    value = add()
    return value

value = lambda : 10 + 20
print(result(value))

output:
-------
30


-->let's prints numbers from 1 to 10, by passing the function as the argument in the list comprehension
example:
--------
def func():
    return 10

print([i for i in range(func())])

output:
-------
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]




Task:
-----
-->in the below list, find the names with maximum marks and sorted the names

solution:
---------
data = [['b', 10], ['c', 20], ['a', 20]]

names = []
marks = []

for i, j in data:
    names.append(i)
    marks.append(j)

max_marks = max(marks)

list1 = []

for i, j in data:
    if j == max_marks:
        list1.append(i)

print(sorted(list1))

output:
-------
['a', 'c']


Task:
-----
-->sort dictionary based on values:

solution:
---------
data = [['b', 10], ['a', 20], ['c', 20]]

names = []
marks = []
dict1 = {}

for i, j in data:
    dict1[i] = j

for i, j in dict1.items():
    value = max(dict1.values())
    if j == value:
        print(i)

output:
-------
a
c


